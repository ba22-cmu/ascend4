# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.2.0
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _ascpy
else:
    import _ascpy

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _ascpy.SWIG_PyInstanceMethod_New
_swig_new_static_method = _ascpy.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ascpy.delete_SwigPyIterator
    value = _swig_new_instance_method(_ascpy.SwigPyIterator_value)
    incr = _swig_new_instance_method(_ascpy.SwigPyIterator_incr)
    decr = _swig_new_instance_method(_ascpy.SwigPyIterator_decr)
    distance = _swig_new_instance_method(_ascpy.SwigPyIterator_distance)
    equal = _swig_new_instance_method(_ascpy.SwigPyIterator_equal)
    copy = _swig_new_instance_method(_ascpy.SwigPyIterator_copy)
    next = _swig_new_instance_method(_ascpy.SwigPyIterator_next)
    __next__ = _swig_new_instance_method(_ascpy.SwigPyIterator___next__)
    previous = _swig_new_instance_method(_ascpy.SwigPyIterator_previous)
    advance = _swig_new_instance_method(_ascpy.SwigPyIterator_advance)
    __eq__ = _swig_new_instance_method(_ascpy.SwigPyIterator___eq__)
    __ne__ = _swig_new_instance_method(_ascpy.SwigPyIterator___ne__)
    __iadd__ = _swig_new_instance_method(_ascpy.SwigPyIterator___iadd__)
    __isub__ = _swig_new_instance_method(_ascpy.SwigPyIterator___isub__)
    __add__ = _swig_new_instance_method(_ascpy.SwigPyIterator___add__)
    __sub__ = _swig_new_instance_method(_ascpy.SwigPyIterator___sub__)
    def __iter__(self):
        return self

# Register SwigPyIterator in _ascpy:
_ascpy.SwigPyIterator_swigregister(SwigPyIterator)

import preferences;


class SetIter:
	def __init__(self,set):
		self.set=set
		self.index=0
	def next(self):
		if self.index==self.set.length():
			raise StopIteration
		self.index = self.index + 1
		return self.set[self.index]

class ModuleVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_ascpy.ModuleVector_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_ascpy.ModuleVector___nonzero__)
    __bool__ = _swig_new_instance_method(_ascpy.ModuleVector___bool__)
    __len__ = _swig_new_instance_method(_ascpy.ModuleVector___len__)
    __getslice__ = _swig_new_instance_method(_ascpy.ModuleVector___getslice__)
    __setslice__ = _swig_new_instance_method(_ascpy.ModuleVector___setslice__)
    __delslice__ = _swig_new_instance_method(_ascpy.ModuleVector___delslice__)
    __delitem__ = _swig_new_instance_method(_ascpy.ModuleVector___delitem__)
    __getitem__ = _swig_new_instance_method(_ascpy.ModuleVector___getitem__)
    __setitem__ = _swig_new_instance_method(_ascpy.ModuleVector___setitem__)
    pop = _swig_new_instance_method(_ascpy.ModuleVector_pop)
    append = _swig_new_instance_method(_ascpy.ModuleVector_append)
    empty = _swig_new_instance_method(_ascpy.ModuleVector_empty)
    size = _swig_new_instance_method(_ascpy.ModuleVector_size)
    swap = _swig_new_instance_method(_ascpy.ModuleVector_swap)
    begin = _swig_new_instance_method(_ascpy.ModuleVector_begin)
    end = _swig_new_instance_method(_ascpy.ModuleVector_end)
    rbegin = _swig_new_instance_method(_ascpy.ModuleVector_rbegin)
    rend = _swig_new_instance_method(_ascpy.ModuleVector_rend)
    clear = _swig_new_instance_method(_ascpy.ModuleVector_clear)
    get_allocator = _swig_new_instance_method(_ascpy.ModuleVector_get_allocator)
    pop_back = _swig_new_instance_method(_ascpy.ModuleVector_pop_back)
    erase = _swig_new_instance_method(_ascpy.ModuleVector_erase)

    def __init__(self, *args):
        _ascpy.ModuleVector_swiginit(self, _ascpy.new_ModuleVector(*args))
    push_back = _swig_new_instance_method(_ascpy.ModuleVector_push_back)
    front = _swig_new_instance_method(_ascpy.ModuleVector_front)
    back = _swig_new_instance_method(_ascpy.ModuleVector_back)
    assign = _swig_new_instance_method(_ascpy.ModuleVector_assign)
    resize = _swig_new_instance_method(_ascpy.ModuleVector_resize)
    insert = _swig_new_instance_method(_ascpy.ModuleVector_insert)
    reserve = _swig_new_instance_method(_ascpy.ModuleVector_reserve)
    capacity = _swig_new_instance_method(_ascpy.ModuleVector_capacity)
    __swig_destroy__ = _ascpy.delete_ModuleVector

# Register ModuleVector in _ascpy:
_ascpy.ModuleVector_swigregister(ModuleVector)
class TypeVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_ascpy.TypeVector_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_ascpy.TypeVector___nonzero__)
    __bool__ = _swig_new_instance_method(_ascpy.TypeVector___bool__)
    __len__ = _swig_new_instance_method(_ascpy.TypeVector___len__)
    __getslice__ = _swig_new_instance_method(_ascpy.TypeVector___getslice__)
    __setslice__ = _swig_new_instance_method(_ascpy.TypeVector___setslice__)
    __delslice__ = _swig_new_instance_method(_ascpy.TypeVector___delslice__)
    __delitem__ = _swig_new_instance_method(_ascpy.TypeVector___delitem__)
    __getitem__ = _swig_new_instance_method(_ascpy.TypeVector___getitem__)
    __setitem__ = _swig_new_instance_method(_ascpy.TypeVector___setitem__)
    pop = _swig_new_instance_method(_ascpy.TypeVector_pop)
    append = _swig_new_instance_method(_ascpy.TypeVector_append)
    empty = _swig_new_instance_method(_ascpy.TypeVector_empty)
    size = _swig_new_instance_method(_ascpy.TypeVector_size)
    swap = _swig_new_instance_method(_ascpy.TypeVector_swap)
    begin = _swig_new_instance_method(_ascpy.TypeVector_begin)
    end = _swig_new_instance_method(_ascpy.TypeVector_end)
    rbegin = _swig_new_instance_method(_ascpy.TypeVector_rbegin)
    rend = _swig_new_instance_method(_ascpy.TypeVector_rend)
    clear = _swig_new_instance_method(_ascpy.TypeVector_clear)
    get_allocator = _swig_new_instance_method(_ascpy.TypeVector_get_allocator)
    pop_back = _swig_new_instance_method(_ascpy.TypeVector_pop_back)
    erase = _swig_new_instance_method(_ascpy.TypeVector_erase)

    def __init__(self, *args):
        _ascpy.TypeVector_swiginit(self, _ascpy.new_TypeVector(*args))
    push_back = _swig_new_instance_method(_ascpy.TypeVector_push_back)
    front = _swig_new_instance_method(_ascpy.TypeVector_front)
    back = _swig_new_instance_method(_ascpy.TypeVector_back)
    assign = _swig_new_instance_method(_ascpy.TypeVector_assign)
    resize = _swig_new_instance_method(_ascpy.TypeVector_resize)
    insert = _swig_new_instance_method(_ascpy.TypeVector_insert)
    reserve = _swig_new_instance_method(_ascpy.TypeVector_reserve)
    capacity = _swig_new_instance_method(_ascpy.TypeVector_capacity)
    __swig_destroy__ = _ascpy.delete_TypeVector

# Register TypeVector in _ascpy:
_ascpy.TypeVector_swigregister(TypeVector)
class MethodVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_ascpy.MethodVector_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_ascpy.MethodVector___nonzero__)
    __bool__ = _swig_new_instance_method(_ascpy.MethodVector___bool__)
    __len__ = _swig_new_instance_method(_ascpy.MethodVector___len__)
    __getslice__ = _swig_new_instance_method(_ascpy.MethodVector___getslice__)
    __setslice__ = _swig_new_instance_method(_ascpy.MethodVector___setslice__)
    __delslice__ = _swig_new_instance_method(_ascpy.MethodVector___delslice__)
    __delitem__ = _swig_new_instance_method(_ascpy.MethodVector___delitem__)
    __getitem__ = _swig_new_instance_method(_ascpy.MethodVector___getitem__)
    __setitem__ = _swig_new_instance_method(_ascpy.MethodVector___setitem__)
    pop = _swig_new_instance_method(_ascpy.MethodVector_pop)
    append = _swig_new_instance_method(_ascpy.MethodVector_append)
    empty = _swig_new_instance_method(_ascpy.MethodVector_empty)
    size = _swig_new_instance_method(_ascpy.MethodVector_size)
    swap = _swig_new_instance_method(_ascpy.MethodVector_swap)
    begin = _swig_new_instance_method(_ascpy.MethodVector_begin)
    end = _swig_new_instance_method(_ascpy.MethodVector_end)
    rbegin = _swig_new_instance_method(_ascpy.MethodVector_rbegin)
    rend = _swig_new_instance_method(_ascpy.MethodVector_rend)
    clear = _swig_new_instance_method(_ascpy.MethodVector_clear)
    get_allocator = _swig_new_instance_method(_ascpy.MethodVector_get_allocator)
    pop_back = _swig_new_instance_method(_ascpy.MethodVector_pop_back)
    erase = _swig_new_instance_method(_ascpy.MethodVector_erase)

    def __init__(self, *args):
        _ascpy.MethodVector_swiginit(self, _ascpy.new_MethodVector(*args))
    push_back = _swig_new_instance_method(_ascpy.MethodVector_push_back)
    front = _swig_new_instance_method(_ascpy.MethodVector_front)
    back = _swig_new_instance_method(_ascpy.MethodVector_back)
    assign = _swig_new_instance_method(_ascpy.MethodVector_assign)
    resize = _swig_new_instance_method(_ascpy.MethodVector_resize)
    insert = _swig_new_instance_method(_ascpy.MethodVector_insert)
    reserve = _swig_new_instance_method(_ascpy.MethodVector_reserve)
    capacity = _swig_new_instance_method(_ascpy.MethodVector_capacity)
    __swig_destroy__ = _ascpy.delete_MethodVector

# Register MethodVector in _ascpy:
_ascpy.MethodVector_swigregister(MethodVector)
class InstancVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_ascpy.InstancVector_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_ascpy.InstancVector___nonzero__)
    __bool__ = _swig_new_instance_method(_ascpy.InstancVector___bool__)
    __len__ = _swig_new_instance_method(_ascpy.InstancVector___len__)
    __getslice__ = _swig_new_instance_method(_ascpy.InstancVector___getslice__)
    __setslice__ = _swig_new_instance_method(_ascpy.InstancVector___setslice__)
    __delslice__ = _swig_new_instance_method(_ascpy.InstancVector___delslice__)
    __delitem__ = _swig_new_instance_method(_ascpy.InstancVector___delitem__)
    __getitem__ = _swig_new_instance_method(_ascpy.InstancVector___getitem__)
    __setitem__ = _swig_new_instance_method(_ascpy.InstancVector___setitem__)
    pop = _swig_new_instance_method(_ascpy.InstancVector_pop)
    append = _swig_new_instance_method(_ascpy.InstancVector_append)
    empty = _swig_new_instance_method(_ascpy.InstancVector_empty)
    size = _swig_new_instance_method(_ascpy.InstancVector_size)
    swap = _swig_new_instance_method(_ascpy.InstancVector_swap)
    begin = _swig_new_instance_method(_ascpy.InstancVector_begin)
    end = _swig_new_instance_method(_ascpy.InstancVector_end)
    rbegin = _swig_new_instance_method(_ascpy.InstancVector_rbegin)
    rend = _swig_new_instance_method(_ascpy.InstancVector_rend)
    clear = _swig_new_instance_method(_ascpy.InstancVector_clear)
    get_allocator = _swig_new_instance_method(_ascpy.InstancVector_get_allocator)
    pop_back = _swig_new_instance_method(_ascpy.InstancVector_pop_back)
    erase = _swig_new_instance_method(_ascpy.InstancVector_erase)

    def __init__(self, *args):
        _ascpy.InstancVector_swiginit(self, _ascpy.new_InstancVector(*args))
    push_back = _swig_new_instance_method(_ascpy.InstancVector_push_back)
    front = _swig_new_instance_method(_ascpy.InstancVector_front)
    back = _swig_new_instance_method(_ascpy.InstancVector_back)
    assign = _swig_new_instance_method(_ascpy.InstancVector_assign)
    resize = _swig_new_instance_method(_ascpy.InstancVector_resize)
    insert = _swig_new_instance_method(_ascpy.InstancVector_insert)
    reserve = _swig_new_instance_method(_ascpy.InstancVector_reserve)
    capacity = _swig_new_instance_method(_ascpy.InstancVector_capacity)
    __swig_destroy__ = _ascpy.delete_InstancVector

# Register InstancVector in _ascpy:
_ascpy.InstancVector_swigregister(InstancVector)
class ExtMethodVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_ascpy.ExtMethodVector_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_ascpy.ExtMethodVector___nonzero__)
    __bool__ = _swig_new_instance_method(_ascpy.ExtMethodVector___bool__)
    __len__ = _swig_new_instance_method(_ascpy.ExtMethodVector___len__)
    __getslice__ = _swig_new_instance_method(_ascpy.ExtMethodVector___getslice__)
    __setslice__ = _swig_new_instance_method(_ascpy.ExtMethodVector___setslice__)
    __delslice__ = _swig_new_instance_method(_ascpy.ExtMethodVector___delslice__)
    __delitem__ = _swig_new_instance_method(_ascpy.ExtMethodVector___delitem__)
    __getitem__ = _swig_new_instance_method(_ascpy.ExtMethodVector___getitem__)
    __setitem__ = _swig_new_instance_method(_ascpy.ExtMethodVector___setitem__)
    pop = _swig_new_instance_method(_ascpy.ExtMethodVector_pop)
    append = _swig_new_instance_method(_ascpy.ExtMethodVector_append)
    empty = _swig_new_instance_method(_ascpy.ExtMethodVector_empty)
    size = _swig_new_instance_method(_ascpy.ExtMethodVector_size)
    swap = _swig_new_instance_method(_ascpy.ExtMethodVector_swap)
    begin = _swig_new_instance_method(_ascpy.ExtMethodVector_begin)
    end = _swig_new_instance_method(_ascpy.ExtMethodVector_end)
    rbegin = _swig_new_instance_method(_ascpy.ExtMethodVector_rbegin)
    rend = _swig_new_instance_method(_ascpy.ExtMethodVector_rend)
    clear = _swig_new_instance_method(_ascpy.ExtMethodVector_clear)
    get_allocator = _swig_new_instance_method(_ascpy.ExtMethodVector_get_allocator)
    pop_back = _swig_new_instance_method(_ascpy.ExtMethodVector_pop_back)
    erase = _swig_new_instance_method(_ascpy.ExtMethodVector_erase)

    def __init__(self, *args):
        _ascpy.ExtMethodVector_swiginit(self, _ascpy.new_ExtMethodVector(*args))
    push_back = _swig_new_instance_method(_ascpy.ExtMethodVector_push_back)
    front = _swig_new_instance_method(_ascpy.ExtMethodVector_front)
    back = _swig_new_instance_method(_ascpy.ExtMethodVector_back)
    assign = _swig_new_instance_method(_ascpy.ExtMethodVector_assign)
    resize = _swig_new_instance_method(_ascpy.ExtMethodVector_resize)
    insert = _swig_new_instance_method(_ascpy.ExtMethodVector_insert)
    reserve = _swig_new_instance_method(_ascpy.ExtMethodVector_reserve)
    capacity = _swig_new_instance_method(_ascpy.ExtMethodVector_capacity)
    __swig_destroy__ = _ascpy.delete_ExtMethodVector

# Register ExtMethodVector in _ascpy:
_ascpy.ExtMethodVector_swigregister(ExtMethodVector)
class SetInt(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    at = _swig_new_instance_method(_ascpy.SetInt_at)
    length = _swig_new_instance_method(_ascpy.SetInt_length)

    def __getitem__(self, index):
    	return self.at(index)
    def __iter__(self):
    	return SetIter(self)

    __swig_destroy__ = _ascpy.delete_SetInt

# Register SetInt in _ascpy:
_ascpy.SetInt_swigregister(SetInt)
class SetString(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    at = _swig_new_instance_method(_ascpy.SetString_at)
    length = _swig_new_instance_method(_ascpy.SetString_length)

    def __getitem__(self, index):
    	return self.at(index)
    def __iter__(self):
    	return SetIter(self)

    __swig_destroy__ = _ascpy.delete_SetString

# Register SetString in _ascpy:
_ascpy.SetString_swigregister(SetString)
class DoubleVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_ascpy.DoubleVector_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_ascpy.DoubleVector___nonzero__)
    __bool__ = _swig_new_instance_method(_ascpy.DoubleVector___bool__)
    __len__ = _swig_new_instance_method(_ascpy.DoubleVector___len__)
    __getslice__ = _swig_new_instance_method(_ascpy.DoubleVector___getslice__)
    __setslice__ = _swig_new_instance_method(_ascpy.DoubleVector___setslice__)
    __delslice__ = _swig_new_instance_method(_ascpy.DoubleVector___delslice__)
    __delitem__ = _swig_new_instance_method(_ascpy.DoubleVector___delitem__)
    __getitem__ = _swig_new_instance_method(_ascpy.DoubleVector___getitem__)
    __setitem__ = _swig_new_instance_method(_ascpy.DoubleVector___setitem__)
    pop = _swig_new_instance_method(_ascpy.DoubleVector_pop)
    append = _swig_new_instance_method(_ascpy.DoubleVector_append)
    empty = _swig_new_instance_method(_ascpy.DoubleVector_empty)
    size = _swig_new_instance_method(_ascpy.DoubleVector_size)
    swap = _swig_new_instance_method(_ascpy.DoubleVector_swap)
    begin = _swig_new_instance_method(_ascpy.DoubleVector_begin)
    end = _swig_new_instance_method(_ascpy.DoubleVector_end)
    rbegin = _swig_new_instance_method(_ascpy.DoubleVector_rbegin)
    rend = _swig_new_instance_method(_ascpy.DoubleVector_rend)
    clear = _swig_new_instance_method(_ascpy.DoubleVector_clear)
    get_allocator = _swig_new_instance_method(_ascpy.DoubleVector_get_allocator)
    pop_back = _swig_new_instance_method(_ascpy.DoubleVector_pop_back)
    erase = _swig_new_instance_method(_ascpy.DoubleVector_erase)

    def __init__(self, *args):
        _ascpy.DoubleVector_swiginit(self, _ascpy.new_DoubleVector(*args))
    push_back = _swig_new_instance_method(_ascpy.DoubleVector_push_back)
    front = _swig_new_instance_method(_ascpy.DoubleVector_front)
    back = _swig_new_instance_method(_ascpy.DoubleVector_back)
    assign = _swig_new_instance_method(_ascpy.DoubleVector_assign)
    resize = _swig_new_instance_method(_ascpy.DoubleVector_resize)
    insert = _swig_new_instance_method(_ascpy.DoubleVector_insert)
    reserve = _swig_new_instance_method(_ascpy.DoubleVector_reserve)
    capacity = _swig_new_instance_method(_ascpy.DoubleVector_capacity)
    __swig_destroy__ = _ascpy.delete_DoubleVector

# Register DoubleVector in _ascpy:
_ascpy.DoubleVector_swigregister(DoubleVector)
class VectorDoubleVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_ascpy.VectorDoubleVector_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_ascpy.VectorDoubleVector___nonzero__)
    __bool__ = _swig_new_instance_method(_ascpy.VectorDoubleVector___bool__)
    __len__ = _swig_new_instance_method(_ascpy.VectorDoubleVector___len__)
    __getslice__ = _swig_new_instance_method(_ascpy.VectorDoubleVector___getslice__)
    __setslice__ = _swig_new_instance_method(_ascpy.VectorDoubleVector___setslice__)
    __delslice__ = _swig_new_instance_method(_ascpy.VectorDoubleVector___delslice__)
    __delitem__ = _swig_new_instance_method(_ascpy.VectorDoubleVector___delitem__)
    __getitem__ = _swig_new_instance_method(_ascpy.VectorDoubleVector___getitem__)
    __setitem__ = _swig_new_instance_method(_ascpy.VectorDoubleVector___setitem__)
    pop = _swig_new_instance_method(_ascpy.VectorDoubleVector_pop)
    append = _swig_new_instance_method(_ascpy.VectorDoubleVector_append)
    empty = _swig_new_instance_method(_ascpy.VectorDoubleVector_empty)
    size = _swig_new_instance_method(_ascpy.VectorDoubleVector_size)
    swap = _swig_new_instance_method(_ascpy.VectorDoubleVector_swap)
    begin = _swig_new_instance_method(_ascpy.VectorDoubleVector_begin)
    end = _swig_new_instance_method(_ascpy.VectorDoubleVector_end)
    rbegin = _swig_new_instance_method(_ascpy.VectorDoubleVector_rbegin)
    rend = _swig_new_instance_method(_ascpy.VectorDoubleVector_rend)
    clear = _swig_new_instance_method(_ascpy.VectorDoubleVector_clear)
    get_allocator = _swig_new_instance_method(_ascpy.VectorDoubleVector_get_allocator)
    pop_back = _swig_new_instance_method(_ascpy.VectorDoubleVector_pop_back)
    erase = _swig_new_instance_method(_ascpy.VectorDoubleVector_erase)

    def __init__(self, *args):
        _ascpy.VectorDoubleVector_swiginit(self, _ascpy.new_VectorDoubleVector(*args))
    push_back = _swig_new_instance_method(_ascpy.VectorDoubleVector_push_back)
    front = _swig_new_instance_method(_ascpy.VectorDoubleVector_front)
    back = _swig_new_instance_method(_ascpy.VectorDoubleVector_back)
    assign = _swig_new_instance_method(_ascpy.VectorDoubleVector_assign)
    resize = _swig_new_instance_method(_ascpy.VectorDoubleVector_resize)
    insert = _swig_new_instance_method(_ascpy.VectorDoubleVector_insert)
    reserve = _swig_new_instance_method(_ascpy.VectorDoubleVector_reserve)
    capacity = _swig_new_instance_method(_ascpy.VectorDoubleVector_capacity)
    __swig_destroy__ = _ascpy.delete_VectorDoubleVector

# Register VectorDoubleVector in _ascpy:
_ascpy.VectorDoubleVector_swigregister(VectorDoubleVector)
class IntVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_ascpy.IntVector_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_ascpy.IntVector___nonzero__)
    __bool__ = _swig_new_instance_method(_ascpy.IntVector___bool__)
    __len__ = _swig_new_instance_method(_ascpy.IntVector___len__)
    __getslice__ = _swig_new_instance_method(_ascpy.IntVector___getslice__)
    __setslice__ = _swig_new_instance_method(_ascpy.IntVector___setslice__)
    __delslice__ = _swig_new_instance_method(_ascpy.IntVector___delslice__)
    __delitem__ = _swig_new_instance_method(_ascpy.IntVector___delitem__)
    __getitem__ = _swig_new_instance_method(_ascpy.IntVector___getitem__)
    __setitem__ = _swig_new_instance_method(_ascpy.IntVector___setitem__)
    pop = _swig_new_instance_method(_ascpy.IntVector_pop)
    append = _swig_new_instance_method(_ascpy.IntVector_append)
    empty = _swig_new_instance_method(_ascpy.IntVector_empty)
    size = _swig_new_instance_method(_ascpy.IntVector_size)
    swap = _swig_new_instance_method(_ascpy.IntVector_swap)
    begin = _swig_new_instance_method(_ascpy.IntVector_begin)
    end = _swig_new_instance_method(_ascpy.IntVector_end)
    rbegin = _swig_new_instance_method(_ascpy.IntVector_rbegin)
    rend = _swig_new_instance_method(_ascpy.IntVector_rend)
    clear = _swig_new_instance_method(_ascpy.IntVector_clear)
    get_allocator = _swig_new_instance_method(_ascpy.IntVector_get_allocator)
    pop_back = _swig_new_instance_method(_ascpy.IntVector_pop_back)
    erase = _swig_new_instance_method(_ascpy.IntVector_erase)

    def __init__(self, *args):
        _ascpy.IntVector_swiginit(self, _ascpy.new_IntVector(*args))
    push_back = _swig_new_instance_method(_ascpy.IntVector_push_back)
    front = _swig_new_instance_method(_ascpy.IntVector_front)
    back = _swig_new_instance_method(_ascpy.IntVector_back)
    assign = _swig_new_instance_method(_ascpy.IntVector_assign)
    resize = _swig_new_instance_method(_ascpy.IntVector_resize)
    insert = _swig_new_instance_method(_ascpy.IntVector_insert)
    reserve = _swig_new_instance_method(_ascpy.IntVector_reserve)
    capacity = _swig_new_instance_method(_ascpy.IntVector_capacity)
    __swig_destroy__ = _ascpy.delete_IntVector

# Register IntVector in _ascpy:
_ascpy.IntVector_swigregister(IntVector)
class CurveVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_ascpy.CurveVector_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_ascpy.CurveVector___nonzero__)
    __bool__ = _swig_new_instance_method(_ascpy.CurveVector___bool__)
    __len__ = _swig_new_instance_method(_ascpy.CurveVector___len__)
    __getslice__ = _swig_new_instance_method(_ascpy.CurveVector___getslice__)
    __setslice__ = _swig_new_instance_method(_ascpy.CurveVector___setslice__)
    __delslice__ = _swig_new_instance_method(_ascpy.CurveVector___delslice__)
    __delitem__ = _swig_new_instance_method(_ascpy.CurveVector___delitem__)
    __getitem__ = _swig_new_instance_method(_ascpy.CurveVector___getitem__)
    __setitem__ = _swig_new_instance_method(_ascpy.CurveVector___setitem__)
    pop = _swig_new_instance_method(_ascpy.CurveVector_pop)
    append = _swig_new_instance_method(_ascpy.CurveVector_append)
    empty = _swig_new_instance_method(_ascpy.CurveVector_empty)
    size = _swig_new_instance_method(_ascpy.CurveVector_size)
    swap = _swig_new_instance_method(_ascpy.CurveVector_swap)
    begin = _swig_new_instance_method(_ascpy.CurveVector_begin)
    end = _swig_new_instance_method(_ascpy.CurveVector_end)
    rbegin = _swig_new_instance_method(_ascpy.CurveVector_rbegin)
    rend = _swig_new_instance_method(_ascpy.CurveVector_rend)
    clear = _swig_new_instance_method(_ascpy.CurveVector_clear)
    get_allocator = _swig_new_instance_method(_ascpy.CurveVector_get_allocator)
    pop_back = _swig_new_instance_method(_ascpy.CurveVector_pop_back)
    erase = _swig_new_instance_method(_ascpy.CurveVector_erase)

    def __init__(self, *args):
        _ascpy.CurveVector_swiginit(self, _ascpy.new_CurveVector(*args))
    push_back = _swig_new_instance_method(_ascpy.CurveVector_push_back)
    front = _swig_new_instance_method(_ascpy.CurveVector_front)
    back = _swig_new_instance_method(_ascpy.CurveVector_back)
    assign = _swig_new_instance_method(_ascpy.CurveVector_assign)
    insert = _swig_new_instance_method(_ascpy.CurveVector_insert)
    reserve = _swig_new_instance_method(_ascpy.CurveVector_reserve)
    capacity = _swig_new_instance_method(_ascpy.CurveVector_capacity)
    __swig_destroy__ = _ascpy.delete_CurveVector

# Register CurveVector in _ascpy:
_ascpy.CurveVector_swigregister(CurveVector)
class StringVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_ascpy.StringVector_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_ascpy.StringVector___nonzero__)
    __bool__ = _swig_new_instance_method(_ascpy.StringVector___bool__)
    __len__ = _swig_new_instance_method(_ascpy.StringVector___len__)
    __getslice__ = _swig_new_instance_method(_ascpy.StringVector___getslice__)
    __setslice__ = _swig_new_instance_method(_ascpy.StringVector___setslice__)
    __delslice__ = _swig_new_instance_method(_ascpy.StringVector___delslice__)
    __delitem__ = _swig_new_instance_method(_ascpy.StringVector___delitem__)
    __getitem__ = _swig_new_instance_method(_ascpy.StringVector___getitem__)
    __setitem__ = _swig_new_instance_method(_ascpy.StringVector___setitem__)
    pop = _swig_new_instance_method(_ascpy.StringVector_pop)
    append = _swig_new_instance_method(_ascpy.StringVector_append)
    empty = _swig_new_instance_method(_ascpy.StringVector_empty)
    size = _swig_new_instance_method(_ascpy.StringVector_size)
    swap = _swig_new_instance_method(_ascpy.StringVector_swap)
    begin = _swig_new_instance_method(_ascpy.StringVector_begin)
    end = _swig_new_instance_method(_ascpy.StringVector_end)
    rbegin = _swig_new_instance_method(_ascpy.StringVector_rbegin)
    rend = _swig_new_instance_method(_ascpy.StringVector_rend)
    clear = _swig_new_instance_method(_ascpy.StringVector_clear)
    get_allocator = _swig_new_instance_method(_ascpy.StringVector_get_allocator)
    pop_back = _swig_new_instance_method(_ascpy.StringVector_pop_back)
    erase = _swig_new_instance_method(_ascpy.StringVector_erase)

    def __init__(self, *args):
        _ascpy.StringVector_swiginit(self, _ascpy.new_StringVector(*args))
    push_back = _swig_new_instance_method(_ascpy.StringVector_push_back)
    front = _swig_new_instance_method(_ascpy.StringVector_front)
    back = _swig_new_instance_method(_ascpy.StringVector_back)
    assign = _swig_new_instance_method(_ascpy.StringVector_assign)
    resize = _swig_new_instance_method(_ascpy.StringVector_resize)
    insert = _swig_new_instance_method(_ascpy.StringVector_insert)
    reserve = _swig_new_instance_method(_ascpy.StringVector_reserve)
    capacity = _swig_new_instance_method(_ascpy.StringVector_capacity)
    __swig_destroy__ = _ascpy.delete_StringVector

# Register StringVector in _ascpy:
_ascpy.StringVector_swigregister(StringVector)
class IntStringMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_ascpy.IntStringMap_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_ascpy.IntStringMap___nonzero__)
    __bool__ = _swig_new_instance_method(_ascpy.IntStringMap___bool__)
    __len__ = _swig_new_instance_method(_ascpy.IntStringMap___len__)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()
    __getitem__ = _swig_new_instance_method(_ascpy.IntStringMap___getitem__)
    __delitem__ = _swig_new_instance_method(_ascpy.IntStringMap___delitem__)
    has_key = _swig_new_instance_method(_ascpy.IntStringMap_has_key)
    keys = _swig_new_instance_method(_ascpy.IntStringMap_keys)
    values = _swig_new_instance_method(_ascpy.IntStringMap_values)
    items = _swig_new_instance_method(_ascpy.IntStringMap_items)
    __contains__ = _swig_new_instance_method(_ascpy.IntStringMap___contains__)
    key_iterator = _swig_new_instance_method(_ascpy.IntStringMap_key_iterator)
    value_iterator = _swig_new_instance_method(_ascpy.IntStringMap_value_iterator)
    __setitem__ = _swig_new_instance_method(_ascpy.IntStringMap___setitem__)
    asdict = _swig_new_instance_method(_ascpy.IntStringMap_asdict)

    def __init__(self, *args):
        _ascpy.IntStringMap_swiginit(self, _ascpy.new_IntStringMap(*args))
    empty = _swig_new_instance_method(_ascpy.IntStringMap_empty)
    size = _swig_new_instance_method(_ascpy.IntStringMap_size)
    swap = _swig_new_instance_method(_ascpy.IntStringMap_swap)
    begin = _swig_new_instance_method(_ascpy.IntStringMap_begin)
    end = _swig_new_instance_method(_ascpy.IntStringMap_end)
    rbegin = _swig_new_instance_method(_ascpy.IntStringMap_rbegin)
    rend = _swig_new_instance_method(_ascpy.IntStringMap_rend)
    clear = _swig_new_instance_method(_ascpy.IntStringMap_clear)
    get_allocator = _swig_new_instance_method(_ascpy.IntStringMap_get_allocator)
    count = _swig_new_instance_method(_ascpy.IntStringMap_count)
    erase = _swig_new_instance_method(_ascpy.IntStringMap_erase)
    find = _swig_new_instance_method(_ascpy.IntStringMap_find)
    lower_bound = _swig_new_instance_method(_ascpy.IntStringMap_lower_bound)
    upper_bound = _swig_new_instance_method(_ascpy.IntStringMap_upper_bound)
    __swig_destroy__ = _ascpy.delete_IntStringMap

# Register IntStringMap in _ascpy:
_ascpy.IntStringMap_swigregister(IntStringMap)
class AnnotationVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_ascpy.AnnotationVector_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_ascpy.AnnotationVector___nonzero__)
    __bool__ = _swig_new_instance_method(_ascpy.AnnotationVector___bool__)
    __len__ = _swig_new_instance_method(_ascpy.AnnotationVector___len__)
    __getslice__ = _swig_new_instance_method(_ascpy.AnnotationVector___getslice__)
    __setslice__ = _swig_new_instance_method(_ascpy.AnnotationVector___setslice__)
    __delslice__ = _swig_new_instance_method(_ascpy.AnnotationVector___delslice__)
    __delitem__ = _swig_new_instance_method(_ascpy.AnnotationVector___delitem__)
    __getitem__ = _swig_new_instance_method(_ascpy.AnnotationVector___getitem__)
    __setitem__ = _swig_new_instance_method(_ascpy.AnnotationVector___setitem__)
    pop = _swig_new_instance_method(_ascpy.AnnotationVector_pop)
    append = _swig_new_instance_method(_ascpy.AnnotationVector_append)
    empty = _swig_new_instance_method(_ascpy.AnnotationVector_empty)
    size = _swig_new_instance_method(_ascpy.AnnotationVector_size)
    swap = _swig_new_instance_method(_ascpy.AnnotationVector_swap)
    begin = _swig_new_instance_method(_ascpy.AnnotationVector_begin)
    end = _swig_new_instance_method(_ascpy.AnnotationVector_end)
    rbegin = _swig_new_instance_method(_ascpy.AnnotationVector_rbegin)
    rend = _swig_new_instance_method(_ascpy.AnnotationVector_rend)
    clear = _swig_new_instance_method(_ascpy.AnnotationVector_clear)
    get_allocator = _swig_new_instance_method(_ascpy.AnnotationVector_get_allocator)
    pop_back = _swig_new_instance_method(_ascpy.AnnotationVector_pop_back)
    erase = _swig_new_instance_method(_ascpy.AnnotationVector_erase)

    def __init__(self, *args):
        _ascpy.AnnotationVector_swiginit(self, _ascpy.new_AnnotationVector(*args))
    push_back = _swig_new_instance_method(_ascpy.AnnotationVector_push_back)
    front = _swig_new_instance_method(_ascpy.AnnotationVector_front)
    back = _swig_new_instance_method(_ascpy.AnnotationVector_back)
    assign = _swig_new_instance_method(_ascpy.AnnotationVector_assign)
    resize = _swig_new_instance_method(_ascpy.AnnotationVector_resize)
    insert = _swig_new_instance_method(_ascpy.AnnotationVector_insert)
    reserve = _swig_new_instance_method(_ascpy.AnnotationVector_reserve)
    capacity = _swig_new_instance_method(_ascpy.AnnotationVector_capacity)
    __swig_destroy__ = _ascpy.delete_AnnotationVector

# Register AnnotationVector in _ascpy:
_ascpy.AnnotationVector_swigregister(AnnotationVector)
class UnitsVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_ascpy.UnitsVector_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_ascpy.UnitsVector___nonzero__)
    __bool__ = _swig_new_instance_method(_ascpy.UnitsVector___bool__)
    __len__ = _swig_new_instance_method(_ascpy.UnitsVector___len__)
    __getslice__ = _swig_new_instance_method(_ascpy.UnitsVector___getslice__)
    __setslice__ = _swig_new_instance_method(_ascpy.UnitsVector___setslice__)
    __delslice__ = _swig_new_instance_method(_ascpy.UnitsVector___delslice__)
    __delitem__ = _swig_new_instance_method(_ascpy.UnitsVector___delitem__)
    __getitem__ = _swig_new_instance_method(_ascpy.UnitsVector___getitem__)
    __setitem__ = _swig_new_instance_method(_ascpy.UnitsVector___setitem__)
    pop = _swig_new_instance_method(_ascpy.UnitsVector_pop)
    append = _swig_new_instance_method(_ascpy.UnitsVector_append)
    empty = _swig_new_instance_method(_ascpy.UnitsVector_empty)
    size = _swig_new_instance_method(_ascpy.UnitsVector_size)
    swap = _swig_new_instance_method(_ascpy.UnitsVector_swap)
    begin = _swig_new_instance_method(_ascpy.UnitsVector_begin)
    end = _swig_new_instance_method(_ascpy.UnitsVector_end)
    rbegin = _swig_new_instance_method(_ascpy.UnitsVector_rbegin)
    rend = _swig_new_instance_method(_ascpy.UnitsVector_rend)
    clear = _swig_new_instance_method(_ascpy.UnitsVector_clear)
    get_allocator = _swig_new_instance_method(_ascpy.UnitsVector_get_allocator)
    pop_back = _swig_new_instance_method(_ascpy.UnitsVector_pop_back)
    erase = _swig_new_instance_method(_ascpy.UnitsVector_erase)

    def __init__(self, *args):
        _ascpy.UnitsVector_swiginit(self, _ascpy.new_UnitsVector(*args))
    push_back = _swig_new_instance_method(_ascpy.UnitsVector_push_back)
    front = _swig_new_instance_method(_ascpy.UnitsVector_front)
    back = _swig_new_instance_method(_ascpy.UnitsVector_back)
    assign = _swig_new_instance_method(_ascpy.UnitsVector_assign)
    resize = _swig_new_instance_method(_ascpy.UnitsVector_resize)
    insert = _swig_new_instance_method(_ascpy.UnitsVector_insert)
    reserve = _swig_new_instance_method(_ascpy.UnitsVector_reserve)
    capacity = _swig_new_instance_method(_ascpy.UnitsVector_capacity)
    __swig_destroy__ = _ascpy.delete_UnitsVector

# Register UnitsVector in _ascpy:
_ascpy.UnitsVector_swigregister(UnitsVector)
class TypeSet(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_ascpy.TypeSet_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_ascpy.TypeSet___nonzero__)
    __bool__ = _swig_new_instance_method(_ascpy.TypeSet___bool__)
    __len__ = _swig_new_instance_method(_ascpy.TypeSet___len__)
    append = _swig_new_instance_method(_ascpy.TypeSet_append)
    __contains__ = _swig_new_instance_method(_ascpy.TypeSet___contains__)
    __getitem__ = _swig_new_instance_method(_ascpy.TypeSet___getitem__)
    add = _swig_new_instance_method(_ascpy.TypeSet_add)
    discard = _swig_new_instance_method(_ascpy.TypeSet_discard)

    def __init__(self, *args):
        _ascpy.TypeSet_swiginit(self, _ascpy.new_TypeSet(*args))
    empty = _swig_new_instance_method(_ascpy.TypeSet_empty)
    size = _swig_new_instance_method(_ascpy.TypeSet_size)
    clear = _swig_new_instance_method(_ascpy.TypeSet_clear)
    swap = _swig_new_instance_method(_ascpy.TypeSet_swap)
    count = _swig_new_instance_method(_ascpy.TypeSet_count)
    begin = _swig_new_instance_method(_ascpy.TypeSet_begin)
    end = _swig_new_instance_method(_ascpy.TypeSet_end)
    rbegin = _swig_new_instance_method(_ascpy.TypeSet_rbegin)
    rend = _swig_new_instance_method(_ascpy.TypeSet_rend)
    erase = _swig_new_instance_method(_ascpy.TypeSet_erase)
    find = _swig_new_instance_method(_ascpy.TypeSet_find)
    lower_bound = _swig_new_instance_method(_ascpy.TypeSet_lower_bound)
    upper_bound = _swig_new_instance_method(_ascpy.TypeSet_upper_bound)
    equal_range = _swig_new_instance_method(_ascpy.TypeSet_equal_range)
    insert = _swig_new_instance_method(_ascpy.TypeSet_insert)
    __swig_destroy__ = _ascpy.delete_TypeSet

# Register TypeSet in _ascpy:
_ascpy.TypeSet_swigregister(TypeSet)
class Reporter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    setErrorCallback = _swig_new_instance_method(_ascpy.Reporter_setErrorCallback)
    setPythonErrorCallback = _swig_new_instance_method(_ascpy.Reporter_setPythonErrorCallback)
    clearPythonErrorCallback = _swig_new_instance_method(_ascpy.Reporter_clearPythonErrorCallback)
    reportError = _swig_new_instance_method(_ascpy.Reporter_reportError)
    reportNote = _swig_new_instance_method(_ascpy.Reporter_reportNote)
    reportWarning = _swig_new_instance_method(_ascpy.Reporter_reportWarning)
    reportSuccess = _swig_new_instance_method(_ascpy.Reporter_reportSuccess)

# Register Reporter in _ascpy:
_ascpy.Reporter_swigregister(Reporter)
getReporter = _ascpy.getReporter
class Dimensions(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    MAX_DIMS = _ascpy.Dimensions_MAX_DIMS
    getBaseUnit = _swig_new_static_method(_ascpy.Dimensions_getBaseUnit)

    def __init__(self, *args):
        _ascpy.Dimensions_swiginit(self, _ascpy.new_Dimensions(*args))
    getInternalType = _swig_new_instance_method(_ascpy.Dimensions_getInternalType)
    toString = _swig_new_instance_method(_ascpy.Dimensions_toString)
    __lt__ = _swig_new_instance_method(_ascpy.Dimensions___lt__)
    __eq__ = _swig_new_instance_method(_ascpy.Dimensions___eq__)
    __ne__ = _swig_new_instance_method(_ascpy.Dimensions___ne__)
    isDimensionless = _swig_new_instance_method(_ascpy.Dimensions_isDimensionless)
    isWild = _swig_new_instance_method(_ascpy.Dimensions_isWild)
    getFractionNumerator = _swig_new_instance_method(_ascpy.Dimensions_getFractionNumerator)
    getFractionDenominator = _swig_new_instance_method(_ascpy.Dimensions_getFractionDenominator)


    def __str__(self):
    	return self.toString()

    def getDefaultUnits(self):
    	"""Return the default (SI) units for a specific set of dimensions."""
    	if self.isWild():
    		return Units("?");

    # create a string representation of the current dimensions
    	numparts=[]
    	denparts=[]
    	for i in range(0, self.MAX_DIMS):
    		baseunit = self.getBaseUnit(i);
    		num = self.getFractionNumerator(i)
    		den = self.getFractionDenominator(i)
    		if num > 0:
    			if den == 1:
    				if num == 1:
    					numparts.append(baseunit)
    				else:
    					numparts.append("%s^%d" % (baseunit, num) )
    			else:
    				numparts.append("%s^(%d/%d)" % (baseunit, num, den) )
    		elif num < 0:
    			if den == 1:
    				if num == -1:
    					denparts.append(baseunit)
    				else:
    					denparts.append("%s^%d" % (baseunit, -num) )
    			else:
    				denparts.append("%s^(%d/%d)" % (baseunit, -num, den) )

    	if len(numparts):
    		str = "*".join(numparts)
    	else:
    		str = "1"

    	if len(denparts):
    		str = str + "/" + "/".join(denparts)

    	return Units(str)


    __swig_destroy__ = _ascpy.delete_Dimensions

# Register Dimensions in _ascpy:
_ascpy.Dimensions_swigregister(Dimensions)
cvar = _ascpy.cvar
Dimensions.BASEUNITS = _ascpy.cvar.Dimensions_BASEUNITS

class Units(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ascpy.Units_swiginit(self, _ascpy.new_Units(*args))
    getName = _swig_new_instance_method(_ascpy.Units_getName)
    getDimensions = _swig_new_instance_method(_ascpy.Units_getDimensions)
    getConversion = _swig_new_instance_method(_ascpy.Units_getConversion)
    __eq__ = _swig_new_instance_method(_ascpy.Units___eq__)

    def getConvertedValue(self,si_value):
    	"""Return an SI value converted to self's units of measurement."""
    	_v = si_value / self.getConversion()
    	_s = str(_v)
    	_n = self.getName().toString()
    	if _n=="1":
    		return _s
    	elif _n=="?":
    		return _s
    	else:
    		return _s + " " + _n;

    __swig_destroy__ = _ascpy.delete_Units

# Register Units in _ascpy:
_ascpy.Units_swigregister(Units)
class Library(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, defaultpath=None):
        _ascpy.Library_swiginit(self, _ascpy.new_Library(defaultpath))
    __swig_destroy__ = _ascpy.delete_Library
    load = _swig_new_instance_method(_ascpy.Library_load)
    loadString = _swig_new_instance_method(_ascpy.Library_loadString)
    getLoadErrorMessage = _swig_new_static_method(_ascpy.Library_getLoadErrorMessage)
    listModules = _swig_new_instance_method(_ascpy.Library_listModules)
    findType = _swig_new_instance_method(_ascpy.Library_findType)
    getModules = _swig_new_instance_method(_ascpy.Library_getModules)
    getModuleTypes = _swig_new_instance_method(_ascpy.Library_getModuleTypes)
    getExtMethods = _swig_new_instance_method(_ascpy.Library_getExtMethods)
    extMethodTraverse = _swig_new_static_method(_ascpy.Library_extMethodTraverse)
    appendToExtMethodVector = _swig_new_instance_method(_ascpy.Library_appendToExtMethodVector)
    clear = _swig_new_instance_method(_ascpy.Library_clear)
    getAnnotationDatabase = _swig_new_instance_method(_ascpy.Library_getAnnotationDatabase)
    getUnits = _swig_new_instance_method(_ascpy.Library_getUnits)
    getRealAtomTypes = _swig_new_instance_method(_ascpy.Library_getRealAtomTypes)

# Register Library in _ascpy:
_ascpy.Library_swigregister(Library)
class SymChar(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, arg2):
        _ascpy.SymChar_swiginit(self, _ascpy.new_SymChar(arg2))
    toString = _swig_new_instance_method(_ascpy.SymChar_toString)
    __repr__ = _swig_new_instance_method(_ascpy.SymChar___repr__)
    __swig_destroy__ = _ascpy.delete_SymChar

# Register SymChar in _ascpy:
_ascpy.SymChar_swigregister(SymChar)
class Module(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    getName = _swig_new_instance_method(_ascpy.Module_getName)
    getFilename = _swig_new_instance_method(_ascpy.Module_getFilename)
    getMtime = _swig_new_instance_method(_ascpy.Module_getMtime)

    def __init__(self):
        _ascpy.Module_swiginit(self, _ascpy.new_Module())
    __swig_destroy__ = _ascpy.delete_Module

# Register Module in _ascpy:
_ascpy.Module_swigregister(Module)
class Method(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ascpy.Method_swiginit(self, _ascpy.new_Method(*args))
    __swig_destroy__ = _ascpy.delete_Method
    getInternalType = _swig_new_instance_method(_ascpy.Method_getInternalType)
    getName = _swig_new_instance_method(_ascpy.Method_getName)
    getSym = _swig_new_instance_method(_ascpy.Method_getSym)

# Register Method in _ascpy:
_ascpy.Method_swigregister(Method)
class Name(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2):
        _ascpy.Name_swiginit(self, _ascpy.new_Name(arg2))
    getName = _swig_new_instance_method(_ascpy.Name_getName)
    __swig_destroy__ = _ascpy.delete_Name

# Register Name in _ascpy:
_ascpy.Name_swigregister(Name)
class Compiler(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    instance = _swig_new_static_method(_ascpy.Compiler_instance)
    getUseRelationSharing = _swig_new_instance_method(_ascpy.Compiler_getUseRelationSharing)
    setUseRelationSharing = _swig_new_instance_method(_ascpy.Compiler_setUseRelationSharing)
    setBinaryCompilation = _swig_new_instance_method(_ascpy.Compiler_setBinaryCompilation)
    setVerbosity = _swig_new_instance_method(_ascpy.Compiler_setVerbosity)

# Register Compiler in _ascpy:
_ascpy.Compiler_swigregister(Compiler)
getCompiler = _ascpy.getCompiler
class Type(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        _ascpy.Type_swiginit(self, _ascpy.new_Type(*args))
    getName = _swig_new_instance_method(_ascpy.Type_getName)
    getParameterCount = _swig_new_instance_method(_ascpy.Type_getParameterCount)
    getInternalType = _swig_new_instance_method(_ascpy.Type_getInternalType)
    getSimulation = _swig_new_instance_method(_ascpy.Type_getSimulation)
    getDimensions = _swig_new_instance_method(_ascpy.Type_getDimensions)
    getMethods = _swig_new_instance_method(_ascpy.Type_getMethods)
    getMethod = _swig_new_instance_method(_ascpy.Type_getMethod)
    isRefinedSolverVar = _swig_new_instance_method(_ascpy.Type_isRefinedSolverVar)
    isRefinedAtom = _swig_new_instance_method(_ascpy.Type_isRefinedAtom)
    isRefinedReal = _swig_new_instance_method(_ascpy.Type_isRefinedReal)
    isRefinedConstant = _swig_new_instance_method(_ascpy.Type_isRefinedConstant)
    isFundamental = _swig_new_instance_method(_ascpy.Type_isFundamental)
    isModel = _swig_new_instance_method(_ascpy.Type_isModel)
    hasParameters = _swig_new_instance_method(_ascpy.Type_hasParameters)
    findMember = _swig_new_instance_method(_ascpy.Type_findMember)
    getModule = _swig_new_instance_method(_ascpy.Type_getModule)
    __lt__ = _swig_new_instance_method(_ascpy.Type___lt__)
    __repr__ = _swig_new_instance_method(_ascpy.Type___repr__)

    def getPreferredUnits(self):
    	"""Return preferred units for an instance, which is done by lookup per atom type."""
    	if not self.isRefinedReal():
    		return None

    	_pref = preferences.Preferences()
    #print "Checking for preferred units for %s" % self.getName()
    	_u = _pref.getPreferredUnits(self.getName().toString())
    	if _u is None:
    # no preferred units set
    		return None
    	_units = Units(_u);

    	if _units.getDimensions() != self.getDimensions():
    		getReporter().reportWarning("Preferred units '%s' for type '%s' are not dimensionally correct: ignoring." % (_u, self.getName()) );
    		return None

    	return _units;

    __swig_destroy__ = _ascpy.delete_Type

# Register Type in _ascpy:
_ascpy.Type_swigregister(Type)
ASCXX_INST_STATUS_UNKNOWN = _ascpy.ASCXX_INST_STATUS_UNKNOWN
ASCXX_VAR_FIXED = _ascpy.ASCXX_VAR_FIXED
ASCXX_VAR_UNSOLVED = _ascpy.ASCXX_VAR_UNSOLVED
ASCXX_VAR_ACTIVE = _ascpy.ASCXX_VAR_ACTIVE
ASCXX_VAR_SOLVED = _ascpy.ASCXX_VAR_SOLVED
ASCXX_REL_INACTIVE = _ascpy.ASCXX_REL_INACTIVE
class Instance(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        _ascpy.Instance_swiginit(self, _ascpy.new_Instance(*args))
    __swig_destroy__ = _ascpy.delete_Instance
    getChildren = _swig_new_instance_method(_ascpy.Instance_getChildren)
    getKindStr = _swig_new_instance_method(_ascpy.Instance_getKindStr)
    getName = _swig_new_instance_method(_ascpy.Instance_getName)
    getType = _swig_new_instance_method(_ascpy.Instance_getType)
    isAtom = _swig_new_instance_method(_ascpy.Instance_isAtom)
    isFixed = _swig_new_instance_method(_ascpy.Instance_isFixed)
    isIncluded = _swig_new_instance_method(_ascpy.Instance_isIncluded)
    isFund = _swig_new_instance_method(_ascpy.Instance_isFund)
    isConst = _swig_new_instance_method(_ascpy.Instance_isConst)
    isAssigned = _swig_new_instance_method(_ascpy.Instance_isAssigned)
    isCompound = _swig_new_instance_method(_ascpy.Instance_isCompound)
    isRelation = _swig_new_instance_method(_ascpy.Instance_isRelation)
    isLogicalRelation = _swig_new_instance_method(_ascpy.Instance_isLogicalRelation)
    isWhen = _swig_new_instance_method(_ascpy.Instance_isWhen)
    isSet = _swig_new_instance_method(_ascpy.Instance_isSet)
    isSetInt = _swig_new_instance_method(_ascpy.Instance_isSetInt)
    isSetString = _swig_new_instance_method(_ascpy.Instance_isSetString)
    isSetEmpty = _swig_new_instance_method(_ascpy.Instance_isSetEmpty)
    isArray = _swig_new_instance_method(_ascpy.Instance_isArray)
    isDefined = _swig_new_instance_method(_ascpy.Instance_isDefined)
    isBool = _swig_new_instance_method(_ascpy.Instance_isBool)
    isInt = _swig_new_instance_method(_ascpy.Instance_isInt)
    isSymbol = _swig_new_instance_method(_ascpy.Instance_isSymbol)
    isReal = _swig_new_instance_method(_ascpy.Instance_isReal)
    isModel = _swig_new_instance_method(_ascpy.Instance_isModel)
    getRealValue = _swig_new_instance_method(_ascpy.Instance_getRealValue)
    isDimensionless = _swig_new_instance_method(_ascpy.Instance_isDimensionless)
    getDimensions = _swig_new_instance_method(_ascpy.Instance_getDimensions)
    getBoolValue = _swig_new_instance_method(_ascpy.Instance_getBoolValue)
    getIntValue = _swig_new_instance_method(_ascpy.Instance_getIntValue)
    getSymbolValue = _swig_new_instance_method(_ascpy.Instance_getSymbolValue)
    getValueAsString = _swig_new_instance_method(_ascpy.Instance_getValueAsString)
    getWhenAsString = _swig_new_instance_method(_ascpy.Instance_getWhenAsString)
    getLogrelAsString = _swig_new_instance_method(_ascpy.Instance_getLogrelAsString)
    getRelationAsString = _swig_new_instance_method(_ascpy.Instance_getRelationAsString)
    getResidual = _swig_new_instance_method(_ascpy.Instance_getResidual)
    getLogicalResidual = _swig_new_instance_method(_ascpy.Instance_getLogicalResidual)
    getPlot = _swig_new_instance_method(_ascpy.Instance_getPlot)
    isPlottable = _swig_new_instance_method(_ascpy.Instance_isPlottable)
    getSetIntValue = _swig_new_instance_method(_ascpy.Instance_getSetIntValue)
    getSetStringValue = _swig_new_instance_method(_ascpy.Instance_getSetStringValue)
    isChildless = _swig_new_instance_method(_ascpy.Instance_isChildless)
    setFixed = _swig_new_instance_method(_ascpy.Instance_setFixed)
    setIncluded = _swig_new_instance_method(_ascpy.Instance_setIncluded)
    setRealValue = _swig_new_instance_method(_ascpy.Instance_setRealValue)
    setRealValueWithUnits = _swig_new_instance_method(_ascpy.Instance_setRealValueWithUnits)
    setBoolValue = _swig_new_instance_method(_ascpy.Instance_setBoolValue)
    setIntValue = _swig_new_instance_method(_ascpy.Instance_setIntValue)
    setSymbolValue = _swig_new_instance_method(_ascpy.Instance_setSymbolValue)
    write = _swig_new_instance_method(_ascpy.Instance_write)
    getStatus = _swig_new_instance_method(_ascpy.Instance_getStatus)
    setLowerBound = _swig_new_instance_method(_ascpy.Instance_setLowerBound)
    setUpperBound = _swig_new_instance_method(_ascpy.Instance_setUpperBound)
    setNominal = _swig_new_instance_method(_ascpy.Instance_setNominal)
    getLowerBound = _swig_new_instance_method(_ascpy.Instance_getLowerBound)
    getUpperBound = _swig_new_instance_method(_ascpy.Instance_getUpperBound)
    getNominal = _swig_new_instance_method(_ascpy.Instance_getNominal)
    getClique = _swig_new_instance_method(_ascpy.Instance_getClique)
    getAliases = _swig_new_instance_method(_ascpy.Instance_getAliases)
    __repr__ = _swig_new_instance_method(_ascpy.Instance___repr__)
    __getattr__ = _swig_new_instance_method(_ascpy.Instance___getattr__)
    __getitem__ = _swig_new_instance_method(_ascpy.Instance___getitem__)
    __float__ = _swig_new_instance_method(_ascpy.Instance___float__)

    def getSetValue(self):
    	"""Return the value of a set, as a integer or string Python sequence."""
    	if self.isSetInt():
    		return self.getSetIntValue()
    	elif self.isSetString():
    		return self.getSetStringValue()
    	elif self.isSetEmpty():
    		return set()
    	else:
    		raise RuntimeError("getSetValue: unknown set type");

    def getValue(self):
    	"""Returns an instance value, including units if applicable."""
    #print "GETTING VALUE OF %s" % self.getName()
    	if self.isCompound():
    		return ""
    	elif self.isRelation():
    		return self.getResidual()
    	elif self.isWhen():
    		return "WHEN"
    	elif self.isSet():
    		_s = set(self.getSetValue());
    #for _v in self.getSetValue():
    #	_s.add( _v )
    		return _s

    	elif ( self.isAtom() or self.isFund() ) and not self.isDefined():
    		return "undefined"
    	elif self.isReal():
    		return self.getRealValueAndUnits()
    	elif self.isBool():
    		return self.getBoolValue()
    	elif self.isInt():
    		return self.getIntValue()
    	elif self.isSymbol():
    		return self.getSymbolValue()
    	elif self.isLogicalRelation():
    		return self.getLogicalResidual()
    	else:
    		return "UNKNOWN TYPE" 
    #raise RuntimeError("Unknown value model type="+self.getType().getName().toString()+", instance kind=".getKindStr())

    def getRealValueAndUnits(self):
    	"""Return real-valued instance value as a string, converted to, and including, its preferred units."""
    	if not self.isReal():
    		raise TypeError
    	if self.isFund():
    		return self.getRealValue();
    	_u = self.getType().getPreferredUnits();
    	if _u is None:
    		_u = self.getDimensions().getDefaultUnits()
    	return _u.getConvertedValue(self.getRealValue())

    def to(self,units):
    	"""Returns an instance value converted to specified units."""
    	if not self.isReal():
    		raise TypeError
    	if units.__class__==str:
    		units = Units(units);
    	if units.__class__!=Units:
    		raise TypeError
    	return self.getRealValue() / units.getConversion()

    def setFixedValue(self,val):
    	"""Set a value to 'fixed', and specify its value, at the same time."""
    	if not self.isFixed():
    		self.setFixed();
    # getReporter().reportError("Setting value of %s to %s" % (self.getName().toString(),val))
    	self.setRealValue(val);

    def __coerce__(self,other):
    	if self.isInt():
    		if other.__class__==int:
    			return self.getIntValue(),int(other)
    		elif other.__class__==float:
    			return float(self.getIntValue()),other
    	elif self.isReal():
    		if other.__class__== int:
    			return self.getRealValue(),float(other)
    		elif other.__class__==float:
    			return self.getRealValue(),other
    	return str(self),str(other)

    def __sub__(self,other):
    	a,b = self.__coerce__(other)
    	return a - b

    def __rsub__(self,other):
    	a,b = self.__coerce__(other)
    	return b - a

    def __add__(self,other):
    	a,b = self.__coerce__(other)
    	return a + b

    def __radd__(self,other):
    	a,b = self.__coerce__(other)
    	return b + a


# Register Instance in _ascpy:
_ascpy.Instance_swigregister(Instance)
class Registry(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    setPointer = _swig_new_instance_method(_ascpy.Registry_setPointer)
    getInstance = _swig_new_instance_method(_ascpy.Registry_getInstance)
    getSimulation = _swig_new_instance_method(_ascpy.Registry_getSimulation)
    set = _swig_new_instance_method(_ascpy.Registry_set)

    def __init__(self):
        _ascpy.Registry_swiginit(self, _ascpy.new_Registry())
    __swig_destroy__ = _ascpy.delete_Registry

# Register Registry in _ascpy:
_ascpy.Registry_swigregister(Registry)
shutdown = _ascpy.shutdown

import types

class Solver(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ascpy.Solver_swiginit(self, _ascpy.new_Solver(*args))
    getIndex = _swig_new_instance_method(_ascpy.Solver_getIndex)
    getName = _swig_new_instance_method(_ascpy.Solver_getName)
    __swig_destroy__ = _ascpy.delete_Solver

# Register Solver in _ascpy:
_ascpy.Solver_swigregister(Solver)
getSolvers = _ascpy.getSolvers
class SingularityInfo(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    isSingular = _swig_new_instance_method(_ascpy.SingularityInfo_isSingular)
    rels = property(_ascpy.SingularityInfo_rels_get, _ascpy.SingularityInfo_rels_set)
    vars = property(_ascpy.SingularityInfo_vars_get, _ascpy.SingularityInfo_vars_set)
    freeablevars = property(_ascpy.SingularityInfo_freeablevars_get, _ascpy.SingularityInfo_freeablevars_set)

    def __init__(self):
        _ascpy.SingularityInfo_swiginit(self, _ascpy.new_SingularityInfo())
    __swig_destroy__ = _ascpy.delete_SingularityInfo

# Register SingularityInfo in _ascpy:
_ascpy.SingularityInfo_swigregister(SingularityInfo)
ASCXX_DOF_UNDERSPECIFIED = _ascpy.ASCXX_DOF_UNDERSPECIFIED
ASCXX_DOF_SQUARE = _ascpy.ASCXX_DOF_SQUARE
ASCXX_DOF_OVERSPECIFIED = _ascpy.ASCXX_DOF_OVERSPECIFIED
ASCXX_DOF_STRUCT_SINGULAR = _ascpy.ASCXX_DOF_STRUCT_SINGULAR
class Simulation(Instance):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ascpy.Simulation_swiginit(self, _ascpy.new_Simulation(*args))
    __swig_destroy__ = _ascpy.delete_Simulation
    getModel = _swig_new_instance_method(_ascpy.Simulation_getModel)
    runDefaultMethod = _swig_new_instance_method(_ascpy.Simulation_runDefaultMethod)
    run = _swig_new_instance_method(_ascpy.Simulation_run)
    checkInstance = _swig_new_instance_method(_ascpy.Simulation_checkInstance)
    checkTokens = _swig_new_instance_method(_ascpy.Simulation_checkTokens)
    checkStructure = _swig_new_instance_method(_ascpy.Simulation_checkStructure)
    checkStatistics = _swig_new_instance_method(_ascpy.Simulation_checkStatistics)
    checkDimensions = _swig_new_instance_method(_ascpy.Simulation_checkDimensions)
    build = _swig_new_instance_method(_ascpy.Simulation_build)
    checkDoF = _swig_new_instance_method(_ascpy.Simulation_checkDoF)
    checkStructuralSingularity = _swig_new_instance_method(_ascpy.Simulation_checkStructuralSingularity)
    getSingularityInfo = _swig_new_instance_method(_ascpy.Simulation_getSingularityInfo)
    solve = _swig_new_instance_method(_ascpy.Simulation_solve)
    presolve = _swig_new_instance_method(_ascpy.Simulation_presolve)
    iterate = _swig_new_instance_method(_ascpy.Simulation_iterate)
    postsolve = _swig_new_instance_method(_ascpy.Simulation_postsolve)
    getStatus = _swig_new_instance_method(_ascpy.Simulation_getStatus)
    getFixableVariables = _swig_new_instance_method(_ascpy.Simulation_getFixableVariables)
    getVariablesNearBounds = _swig_new_instance_method(_ascpy.Simulation_getVariablesNearBounds)
    getVariablesFarFromNominals = _swig_new_instance_method(_ascpy.Simulation_getVariablesFarFromNominals)
    getFixedVariables = _swig_new_instance_method(_ascpy.Simulation_getFixedVariables)
    getallVariables = _swig_new_instance_method(_ascpy.Simulation_getallVariables)
    getMatrix = _swig_new_instance_method(_ascpy.Simulation_getMatrix)
    write = _swig_new_instance_method(_ascpy.Simulation_write)
    setSolver = _swig_new_instance_method(_ascpy.Simulation_setSolver)
    getSolver = _swig_new_instance_method(_ascpy.Simulation_getSolver)
    getParameters = _swig_new_instance_method(_ascpy.Simulation_getParameters)
    setParameters = _swig_new_instance_method(_ascpy.Simulation_setParameters)
    getIncidenceMatrix = _swig_new_instance_method(_ascpy.Simulation_getIncidenceMatrix)
    getInstanceName = _swig_new_instance_method(_ascpy.Simulation_getInstanceName)
    processVarStatus = _swig_new_instance_method(_ascpy.Simulation_processVarStatus)
    getNumVars = _swig_new_instance_method(_ascpy.Simulation_getNumVars)
    getActiveBlock = _swig_new_instance_method(_ascpy.Simulation_getActiveBlock)
    getFreeableVariables = _swig_new_instance_method(_ascpy.Simulation_getFreeableVariables)
    setSolverHooks = _swig_new_instance_method(_ascpy.Simulation_setSolverHooks)
    getSolverHooks = _swig_new_instance_method(_ascpy.Simulation_getSolverHooks)
    __getitem__ = _swig_new_instance_method(_ascpy.Simulation___getitem__)
    __getattr__ = _swig_new_instance_method(_ascpy.Simulation___getattr__)

    def setParameter(self,name,value):
    	""" set the value of a parameter for this integrator """
    	P = self.getParameters()
    	P.set(name,value)
    	self.setParameters(P)
    def getParameterValue(self,name):
    	""" retrieve the *value* of the specified parameter """
    	P = self.getParameters()
    	for p in P:
    		if p.getName()==name:
    			return p.getValue()
    	raise KeyError


# Register Simulation in _ascpy:
_ascpy.Simulation_swigregister(Simulation)
class Matrix(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ascpy.Matrix_swiginit(self, _ascpy.new_Matrix(*args))
    write = _swig_new_instance_method(_ascpy.Matrix_write)
    size = _swig_new_instance_method(_ascpy.Matrix_size)
    __swig_destroy__ = _ascpy.delete_Matrix

# Register Matrix in _ascpy:
_ascpy.Matrix_swigregister(Matrix)

from builtins import object
class SolverParameterIter(object):
	def __init__(self, params):
		self.params = params;
		self.index = 0;

	def __iter__(self):
		return self

	def __next__(self):
		if self.index >= len(self.params):
			raise StopIteration
		p = self.params.getParameter(self.index)
		self.index = self.index +1
		return p

class SolverParameters(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    toString = _swig_new_instance_method(_ascpy.SolverParameters_toString)

    def __init__(self, arg2):
        _ascpy.SolverParameters_swiginit(self, _ascpy.new_SolverParameters(arg2))
    getLength = _swig_new_instance_method(_ascpy.SolverParameters_getLength)
    getParameter = _swig_new_instance_method(_ascpy.SolverParameters_getParameter)

    def __iter__(self):
    	return SolverParameterIter(self)
    def __getattr(self,index):
    	for p in self:
    		if p.getName()==index:
    			return p
    	raise KeyError
    def __getitem__(self,index):
    	if type(index) != types.IntType:
    		raise TypeError
    	return self.getParameter(index)
    def __len__(self):
    	return self.getLength()
    def getValue(self,codename):
    	for p in self:
    		if p.getName()==codename:
    			return p.getValue()
    	raise KeyError
    def set(self,codename,value):
    	for p in self:
    		if p.getName()==codename:
    			p.setValue(value)
    			return
    	raise KeyError

    __swig_destroy__ = _ascpy.delete_SolverParameters

# Register SolverParameters in _ascpy:
_ascpy.SolverParameters_swigregister(SolverParameters)
VALUE_INT = _ascpy.VALUE_INT
VALUE_REAL = _ascpy.VALUE_REAL
VALUE_BOOL = _ascpy.VALUE_BOOL
VALUE_CHAR = _ascpy.VALUE_CHAR
VALUE_UNIMPLEMENTED = _ascpy.VALUE_UNIMPLEMENTED
class Value(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ascpy.Value_swiginit(self, _ascpy.new_Value(*args))
    __swig_destroy__ = _ascpy.delete_Value
    getType = _swig_new_instance_method(_ascpy.Value_getType)

# Register Value in _ascpy:
_ascpy.Value_swigregister(Value)
class SolverParameter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2):
        _ascpy.SolverParameter_swiginit(self, _ascpy.new_SolverParameter(arg2))
    getName = _swig_new_instance_method(_ascpy.SolverParameter_getName)
    getDescription = _swig_new_instance_method(_ascpy.SolverParameter_getDescription)
    getLabel = _swig_new_instance_method(_ascpy.SolverParameter_getLabel)
    getNumber = _swig_new_instance_method(_ascpy.SolverParameter_getNumber)
    getPage = _swig_new_instance_method(_ascpy.SolverParameter_getPage)
    isInt = _swig_new_instance_method(_ascpy.SolverParameter_isInt)
    isBool = _swig_new_instance_method(_ascpy.SolverParameter_isBool)
    isStr = _swig_new_instance_method(_ascpy.SolverParameter_isStr)
    isReal = _swig_new_instance_method(_ascpy.SolverParameter_isReal)
    getIntValue = _swig_new_instance_method(_ascpy.SolverParameter_getIntValue)
    getIntLowerBound = _swig_new_instance_method(_ascpy.SolverParameter_getIntLowerBound)
    getIntUpperBound = _swig_new_instance_method(_ascpy.SolverParameter_getIntUpperBound)
    setIntValue = _swig_new_instance_method(_ascpy.SolverParameter_setIntValue)
    getBoolValue = _swig_new_instance_method(_ascpy.SolverParameter_getBoolValue)
    setBoolValue = _swig_new_instance_method(_ascpy.SolverParameter_setBoolValue)
    getStrValue = _swig_new_instance_method(_ascpy.SolverParameter_getStrValue)
    getStrOptions = _swig_new_instance_method(_ascpy.SolverParameter_getStrOptions)
    setStrValue = _swig_new_instance_method(_ascpy.SolverParameter_setStrValue)
    setStrOption = _swig_new_instance_method(_ascpy.SolverParameter_setStrOption)
    getRealValue = _swig_new_instance_method(_ascpy.SolverParameter_getRealValue)
    getRealLowerBound = _swig_new_instance_method(_ascpy.SolverParameter_getRealLowerBound)
    getRealUpperBound = _swig_new_instance_method(_ascpy.SolverParameter_getRealUpperBound)
    setRealValue = _swig_new_instance_method(_ascpy.SolverParameter_setRealValue)
    isBounded = _swig_new_instance_method(_ascpy.SolverParameter_isBounded)
    toString = _swig_new_instance_method(_ascpy.SolverParameter_toString)
    setValueValue = _swig_new_instance_method(_ascpy.SolverParameter_setValueValue)

    def __str__(self):
    	if self.isInt(): return "%s = %d" %(self.getName(),self.getIntValue())
    	if self.isBool(): return "%s = %s" %(self.getName(),self.getBoolValue())
    	if self.isStr(): return "%s = %s" %(self.getName(),self.getStrValue())
    	if self.isReal(): return "%s = %f" %(self.getName(),self.getRealValue())
    	raise TypeError
    def getValue(self):
    	if self.isBool():return self.getBoolValue()
    	if self.isReal():return self.getRealValue()
    	if self.isInt(): return self.getIntValue()
    	if self.isStr(): return self.getStrValue()
    	raise TypeError
    def setValue(self,value):
    	if self.isBool():
    		self.setBoolValue(value)
    		return
    	if self.isReal():
    		self.setRealValue(value)
    		return
    	if self.isInt():
    		self.setIntValue(value)
    		return
    	if self.isStr():
    		self.setStrValue(bytes(value))
    		return
    	raise TypeError

    __swig_destroy__ = _ascpy.delete_SolverParameter

# Register SolverParameter in _ascpy:
_ascpy.SolverParameter_swigregister(SolverParameter)
class IncidencePointVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_ascpy.IncidencePointVector_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_ascpy.IncidencePointVector___nonzero__)
    __bool__ = _swig_new_instance_method(_ascpy.IncidencePointVector___bool__)
    __len__ = _swig_new_instance_method(_ascpy.IncidencePointVector___len__)
    __getslice__ = _swig_new_instance_method(_ascpy.IncidencePointVector___getslice__)
    __setslice__ = _swig_new_instance_method(_ascpy.IncidencePointVector___setslice__)
    __delslice__ = _swig_new_instance_method(_ascpy.IncidencePointVector___delslice__)
    __delitem__ = _swig_new_instance_method(_ascpy.IncidencePointVector___delitem__)
    __getitem__ = _swig_new_instance_method(_ascpy.IncidencePointVector___getitem__)
    __setitem__ = _swig_new_instance_method(_ascpy.IncidencePointVector___setitem__)
    pop = _swig_new_instance_method(_ascpy.IncidencePointVector_pop)
    append = _swig_new_instance_method(_ascpy.IncidencePointVector_append)
    empty = _swig_new_instance_method(_ascpy.IncidencePointVector_empty)
    size = _swig_new_instance_method(_ascpy.IncidencePointVector_size)
    swap = _swig_new_instance_method(_ascpy.IncidencePointVector_swap)
    begin = _swig_new_instance_method(_ascpy.IncidencePointVector_begin)
    end = _swig_new_instance_method(_ascpy.IncidencePointVector_end)
    rbegin = _swig_new_instance_method(_ascpy.IncidencePointVector_rbegin)
    rend = _swig_new_instance_method(_ascpy.IncidencePointVector_rend)
    clear = _swig_new_instance_method(_ascpy.IncidencePointVector_clear)
    get_allocator = _swig_new_instance_method(_ascpy.IncidencePointVector_get_allocator)
    pop_back = _swig_new_instance_method(_ascpy.IncidencePointVector_pop_back)
    erase = _swig_new_instance_method(_ascpy.IncidencePointVector_erase)

    def __init__(self, *args):
        _ascpy.IncidencePointVector_swiginit(self, _ascpy.new_IncidencePointVector(*args))
    push_back = _swig_new_instance_method(_ascpy.IncidencePointVector_push_back)
    front = _swig_new_instance_method(_ascpy.IncidencePointVector_front)
    back = _swig_new_instance_method(_ascpy.IncidencePointVector_back)
    assign = _swig_new_instance_method(_ascpy.IncidencePointVector_assign)
    resize = _swig_new_instance_method(_ascpy.IncidencePointVector_resize)
    insert = _swig_new_instance_method(_ascpy.IncidencePointVector_insert)
    reserve = _swig_new_instance_method(_ascpy.IncidencePointVector_reserve)
    capacity = _swig_new_instance_method(_ascpy.IncidencePointVector_capacity)
    __swig_destroy__ = _ascpy.delete_IncidencePointVector

# Register IncidencePointVector in _ascpy:
_ascpy.IncidencePointVector_swigregister(IncidencePointVector)
IM_NULL = _ascpy.IM_NULL
IM_ACTIVE_FIXED = _ascpy.IM_ACTIVE_FIXED
IM_ACTIVE_FREE = _ascpy.IM_ACTIVE_FREE
IM_DORMANT_FIXED = _ascpy.IM_DORMANT_FIXED
IM_DORMANT_FREE = _ascpy.IM_DORMANT_FREE
IM_CONVERGED = _ascpy.IM_CONVERGED
IM_OVER_ITER = _ascpy.IM_OVER_ITER
IM_OVER_TIME = _ascpy.IM_OVER_TIME
IM_DIVERGED = _ascpy.IM_DIVERGED
IM_NOT_YET_ATTEMPTED = _ascpy.IM_NOT_YET_ATTEMPTED
class IncidencePoint(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ascpy.IncidencePoint_swiginit(self, _ascpy.new_IncidencePoint(*args))
    row = property(_ascpy.IncidencePoint_row_get, _ascpy.IncidencePoint_row_set)
    col = property(_ascpy.IncidencePoint_col_get, _ascpy.IncidencePoint_col_set)
    type = property(_ascpy.IncidencePoint_type_get, _ascpy.IncidencePoint_type_set)

    def __repr__(self):
    	return str([ self.row, self.col, int(self.type) ]);

    __swig_destroy__ = _ascpy.delete_IncidencePoint

# Register IncidencePoint in _ascpy:
_ascpy.IncidencePoint_swigregister(IncidencePoint)
class IncidenceMatrix(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, sim):
        _ascpy.IncidenceMatrix_swiginit(self, _ascpy.new_IncidenceMatrix(sim))
    __swig_destroy__ = _ascpy.delete_IncidenceMatrix
    getIncidenceData = _swig_new_instance_method(_ascpy.IncidenceMatrix_getIncidenceData)
    getNumRows = _swig_new_instance_method(_ascpy.IncidenceMatrix_getNumRows)
    getNumCols = _swig_new_instance_method(_ascpy.IncidenceMatrix_getNumCols)
    getVariable = _swig_new_instance_method(_ascpy.IncidenceMatrix_getVariable)
    getRelation = _swig_new_instance_method(_ascpy.IncidenceMatrix_getRelation)
    getBlockRow = _swig_new_instance_method(_ascpy.IncidenceMatrix_getBlockRow)
    getBlockVars = _swig_new_instance_method(_ascpy.IncidenceMatrix_getBlockVars)
    getBlockRels = _swig_new_instance_method(_ascpy.IncidenceMatrix_getBlockRels)
    getBlockLocation = _swig_new_instance_method(_ascpy.IncidenceMatrix_getBlockLocation)
    getBlockStatus = _swig_new_instance_method(_ascpy.IncidenceMatrix_getBlockStatus)
    getNumBlocks = _swig_new_instance_method(_ascpy.IncidenceMatrix_getNumBlocks)

# Register IncidenceMatrix in _ascpy:
_ascpy.IncidenceMatrix_swigregister(IncidenceMatrix)
class Variable(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ascpy.Variable_swiginit(self, _ascpy.new_Variable(*args))
    getName = _swig_new_instance_method(_ascpy.Variable_getName)
    getValue = _swig_new_instance_method(_ascpy.Variable_getValue)
    getNominal = _swig_new_instance_method(_ascpy.Variable_getNominal)
    getUpperBound = _swig_new_instance_method(_ascpy.Variable_getUpperBound)
    getLowerBound = _swig_new_instance_method(_ascpy.Variable_getLowerBound)
    getIncidentRelations = _swig_new_instance_method(_ascpy.Variable_getIncidentRelations)
    getNumIncidentRelations = _swig_new_instance_method(_ascpy.Variable_getNumIncidentRelations)
    getInstance = _swig_new_instance_method(_ascpy.Variable_getInstance)

    def __repr__(self):
    	return self.getName()

    __swig_destroy__ = _ascpy.delete_Variable

# Register Variable in _ascpy:
_ascpy.Variable_swigregister(Variable)
class Relation(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, old):
        _ascpy.Relation_swiginit(self, _ascpy.new_Relation(old))
    getName = _swig_new_instance_method(_ascpy.Relation_getName)
    getResidual = _swig_new_instance_method(_ascpy.Relation_getResidual)
    getIncidentVariables = _swig_new_instance_method(_ascpy.Relation_getIncidentVariables)
    getNumIncidentVariables = _swig_new_instance_method(_ascpy.Relation_getNumIncidentVariables)
    getInstance = _swig_new_instance_method(_ascpy.Relation_getInstance)
    getRelationAsString = _swig_new_instance_method(_ascpy.Relation_getRelationAsString)

    def __repr__(self):
    	return self.getName()

    __swig_destroy__ = _ascpy.delete_Relation

# Register Relation in _ascpy:
_ascpy.Relation_swigregister(Relation)
class VariableVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_ascpy.VariableVector_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_ascpy.VariableVector___nonzero__)
    __bool__ = _swig_new_instance_method(_ascpy.VariableVector___bool__)
    __len__ = _swig_new_instance_method(_ascpy.VariableVector___len__)
    __getslice__ = _swig_new_instance_method(_ascpy.VariableVector___getslice__)
    __setslice__ = _swig_new_instance_method(_ascpy.VariableVector___setslice__)
    __delslice__ = _swig_new_instance_method(_ascpy.VariableVector___delslice__)
    __delitem__ = _swig_new_instance_method(_ascpy.VariableVector___delitem__)
    __getitem__ = _swig_new_instance_method(_ascpy.VariableVector___getitem__)
    __setitem__ = _swig_new_instance_method(_ascpy.VariableVector___setitem__)
    pop = _swig_new_instance_method(_ascpy.VariableVector_pop)
    append = _swig_new_instance_method(_ascpy.VariableVector_append)
    empty = _swig_new_instance_method(_ascpy.VariableVector_empty)
    size = _swig_new_instance_method(_ascpy.VariableVector_size)
    swap = _swig_new_instance_method(_ascpy.VariableVector_swap)
    begin = _swig_new_instance_method(_ascpy.VariableVector_begin)
    end = _swig_new_instance_method(_ascpy.VariableVector_end)
    rbegin = _swig_new_instance_method(_ascpy.VariableVector_rbegin)
    rend = _swig_new_instance_method(_ascpy.VariableVector_rend)
    clear = _swig_new_instance_method(_ascpy.VariableVector_clear)
    get_allocator = _swig_new_instance_method(_ascpy.VariableVector_get_allocator)
    pop_back = _swig_new_instance_method(_ascpy.VariableVector_pop_back)
    erase = _swig_new_instance_method(_ascpy.VariableVector_erase)

    def __init__(self, *args):
        _ascpy.VariableVector_swiginit(self, _ascpy.new_VariableVector(*args))
    push_back = _swig_new_instance_method(_ascpy.VariableVector_push_back)
    front = _swig_new_instance_method(_ascpy.VariableVector_front)
    back = _swig_new_instance_method(_ascpy.VariableVector_back)
    assign = _swig_new_instance_method(_ascpy.VariableVector_assign)
    resize = _swig_new_instance_method(_ascpy.VariableVector_resize)
    insert = _swig_new_instance_method(_ascpy.VariableVector_insert)
    reserve = _swig_new_instance_method(_ascpy.VariableVector_reserve)
    capacity = _swig_new_instance_method(_ascpy.VariableVector_capacity)
    __swig_destroy__ = _ascpy.delete_VariableVector

# Register VariableVector in _ascpy:
_ascpy.VariableVector_swigregister(VariableVector)
class RelationVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_ascpy.RelationVector_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_ascpy.RelationVector___nonzero__)
    __bool__ = _swig_new_instance_method(_ascpy.RelationVector___bool__)
    __len__ = _swig_new_instance_method(_ascpy.RelationVector___len__)
    __getslice__ = _swig_new_instance_method(_ascpy.RelationVector___getslice__)
    __setslice__ = _swig_new_instance_method(_ascpy.RelationVector___setslice__)
    __delslice__ = _swig_new_instance_method(_ascpy.RelationVector___delslice__)
    __delitem__ = _swig_new_instance_method(_ascpy.RelationVector___delitem__)
    __getitem__ = _swig_new_instance_method(_ascpy.RelationVector___getitem__)
    __setitem__ = _swig_new_instance_method(_ascpy.RelationVector___setitem__)
    pop = _swig_new_instance_method(_ascpy.RelationVector_pop)
    append = _swig_new_instance_method(_ascpy.RelationVector_append)
    empty = _swig_new_instance_method(_ascpy.RelationVector_empty)
    size = _swig_new_instance_method(_ascpy.RelationVector_size)
    swap = _swig_new_instance_method(_ascpy.RelationVector_swap)
    begin = _swig_new_instance_method(_ascpy.RelationVector_begin)
    end = _swig_new_instance_method(_ascpy.RelationVector_end)
    rbegin = _swig_new_instance_method(_ascpy.RelationVector_rbegin)
    rend = _swig_new_instance_method(_ascpy.RelationVector_rend)
    clear = _swig_new_instance_method(_ascpy.RelationVector_clear)
    get_allocator = _swig_new_instance_method(_ascpy.RelationVector_get_allocator)
    pop_back = _swig_new_instance_method(_ascpy.RelationVector_pop_back)
    erase = _swig_new_instance_method(_ascpy.RelationVector_erase)

    def __init__(self, *args):
        _ascpy.RelationVector_swiginit(self, _ascpy.new_RelationVector(*args))
    push_back = _swig_new_instance_method(_ascpy.RelationVector_push_back)
    front = _swig_new_instance_method(_ascpy.RelationVector_front)
    back = _swig_new_instance_method(_ascpy.RelationVector_back)
    assign = _swig_new_instance_method(_ascpy.RelationVector_assign)
    resize = _swig_new_instance_method(_ascpy.RelationVector_resize)
    insert = _swig_new_instance_method(_ascpy.RelationVector_insert)
    reserve = _swig_new_instance_method(_ascpy.RelationVector_reserve)
    capacity = _swig_new_instance_method(_ascpy.RelationVector_capacity)
    __swig_destroy__ = _ascpy.delete_RelationVector

# Register RelationVector in _ascpy:
_ascpy.RelationVector_swigregister(RelationVector)
class SolverVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_ascpy.SolverVector_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_ascpy.SolverVector___nonzero__)
    __bool__ = _swig_new_instance_method(_ascpy.SolverVector___bool__)
    __len__ = _swig_new_instance_method(_ascpy.SolverVector___len__)
    __getslice__ = _swig_new_instance_method(_ascpy.SolverVector___getslice__)
    __setslice__ = _swig_new_instance_method(_ascpy.SolverVector___setslice__)
    __delslice__ = _swig_new_instance_method(_ascpy.SolverVector___delslice__)
    __delitem__ = _swig_new_instance_method(_ascpy.SolverVector___delitem__)
    __getitem__ = _swig_new_instance_method(_ascpy.SolverVector___getitem__)
    __setitem__ = _swig_new_instance_method(_ascpy.SolverVector___setitem__)
    pop = _swig_new_instance_method(_ascpy.SolverVector_pop)
    append = _swig_new_instance_method(_ascpy.SolverVector_append)
    empty = _swig_new_instance_method(_ascpy.SolverVector_empty)
    size = _swig_new_instance_method(_ascpy.SolverVector_size)
    swap = _swig_new_instance_method(_ascpy.SolverVector_swap)
    begin = _swig_new_instance_method(_ascpy.SolverVector_begin)
    end = _swig_new_instance_method(_ascpy.SolverVector_end)
    rbegin = _swig_new_instance_method(_ascpy.SolverVector_rbegin)
    rend = _swig_new_instance_method(_ascpy.SolverVector_rend)
    clear = _swig_new_instance_method(_ascpy.SolverVector_clear)
    get_allocator = _swig_new_instance_method(_ascpy.SolverVector_get_allocator)
    pop_back = _swig_new_instance_method(_ascpy.SolverVector_pop_back)
    erase = _swig_new_instance_method(_ascpy.SolverVector_erase)

    def __init__(self, *args):
        _ascpy.SolverVector_swiginit(self, _ascpy.new_SolverVector(*args))
    push_back = _swig_new_instance_method(_ascpy.SolverVector_push_back)
    front = _swig_new_instance_method(_ascpy.SolverVector_front)
    back = _swig_new_instance_method(_ascpy.SolverVector_back)
    assign = _swig_new_instance_method(_ascpy.SolverVector_assign)
    resize = _swig_new_instance_method(_ascpy.SolverVector_resize)
    insert = _swig_new_instance_method(_ascpy.SolverVector_insert)
    reserve = _swig_new_instance_method(_ascpy.SolverVector_reserve)
    capacity = _swig_new_instance_method(_ascpy.SolverVector_capacity)
    __swig_destroy__ = _ascpy.delete_SolverVector

# Register SolverVector in _ascpy:
_ascpy.SolverVector_swigregister(SolverVector)
class SolverStatus(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ascpy.SolverStatus_swiginit(self, _ascpy.new_SolverStatus(*args))
    getSimulationStatus = _swig_new_instance_method(_ascpy.SolverStatus_getSimulationStatus)
    isOK = _swig_new_instance_method(_ascpy.SolverStatus_isOK)
    isOverDefined = _swig_new_instance_method(_ascpy.SolverStatus_isOverDefined)
    isUnderDefined = _swig_new_instance_method(_ascpy.SolverStatus_isUnderDefined)
    isStructurallySingular = _swig_new_instance_method(_ascpy.SolverStatus_isStructurallySingular)
    isInconsistent = _swig_new_instance_method(_ascpy.SolverStatus_isInconsistent)
    isReadyToSolve = _swig_new_instance_method(_ascpy.SolverStatus_isReadyToSolve)
    isConverged = _swig_new_instance_method(_ascpy.SolverStatus_isConverged)
    isDiverged = _swig_new_instance_method(_ascpy.SolverStatus_isDiverged)
    hasResidualCalculationErrors = _swig_new_instance_method(_ascpy.SolverStatus_hasResidualCalculationErrors)
    hasExceededIterationLimit = _swig_new_instance_method(_ascpy.SolverStatus_hasExceededIterationLimit)
    hasExceededTimeLimit = _swig_new_instance_method(_ascpy.SolverStatus_hasExceededTimeLimit)
    isInterrupted = _swig_new_instance_method(_ascpy.SolverStatus_isInterrupted)
    getIterationNum = _swig_new_instance_method(_ascpy.SolverStatus_getIterationNum)
    getNumBlocks = _swig_new_instance_method(_ascpy.SolverStatus_getNumBlocks)
    getCurrentBlockNum = _swig_new_instance_method(_ascpy.SolverStatus_getCurrentBlockNum)
    getCurrentBlockSize = _swig_new_instance_method(_ascpy.SolverStatus_getCurrentBlockSize)
    getCurrentBlockIteration = _swig_new_instance_method(_ascpy.SolverStatus_getCurrentBlockIteration)
    getNumConverged = _swig_new_instance_method(_ascpy.SolverStatus_getNumConverged)
    getNumJacobianEvals = _swig_new_instance_method(_ascpy.SolverStatus_getNumJacobianEvals)
    getNumResidualEvals = _swig_new_instance_method(_ascpy.SolverStatus_getNumResidualEvals)
    getBlockResidualRMS = _swig_new_instance_method(_ascpy.SolverStatus_getBlockResidualRMS)
    __swig_destroy__ = _ascpy.delete_SolverStatus

# Register SolverStatus in _ascpy:
_ascpy.SolverStatus_swigregister(SolverStatus)
class SolverReporter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == SolverReporter:
            _self = None
        else:
            _self = self
        _ascpy.SolverReporter_swiginit(self, _ascpy.new_SolverReporter(_self, ))
    __swig_destroy__ = _ascpy.delete_SolverReporter
    report = _swig_new_instance_method(_ascpy.SolverReporter_report)
    finalise = _swig_new_instance_method(_ascpy.SolverReporter_finalise)
    def __disown__(self):
        self.this.disown()
        _ascpy.disown_SolverReporter(self)
        return weakref.proxy(self)

# Register SolverReporter in _ascpy:
_ascpy.SolverReporter_swigregister(SolverReporter)
class Integrator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2):
        _ascpy.Integrator_swiginit(self, _ascpy.new_Integrator(arg2))
    __swig_destroy__ = _ascpy.delete_Integrator
    getEngines = _swig_new_static_method(_ascpy.Integrator_getEngines)
    setEngine = _swig_new_instance_method(_ascpy.Integrator_setEngine)
    getName = _swig_new_instance_method(_ascpy.Integrator_getName)
    getParameters = _swig_new_instance_method(_ascpy.Integrator_getParameters)
    setParameters = _swig_new_instance_method(_ascpy.Integrator_setParameters)
    setReporter = _swig_new_instance_method(_ascpy.Integrator_setReporter)
    setMinSubStep = _swig_new_instance_method(_ascpy.Integrator_setMinSubStep)
    setMaxSubStep = _swig_new_instance_method(_ascpy.Integrator_setMaxSubStep)
    setInitialSubStep = _swig_new_instance_method(_ascpy.Integrator_setInitialSubStep)
    setMaxSubSteps = _swig_new_instance_method(_ascpy.Integrator_setMaxSubSteps)
    setLinearTimesteps = _swig_new_instance_method(_ascpy.Integrator_setLinearTimesteps)
    setLogTimesteps = _swig_new_instance_method(_ascpy.Integrator_setLogTimesteps)
    getCurrentObservations = _swig_new_instance_method(_ascpy.Integrator_getCurrentObservations)
    saveObservations = _swig_new_instance_method(_ascpy.Integrator_saveObservations)
    getObservations = _swig_new_instance_method(_ascpy.Integrator_getObservations)
    getObservedVariable = _swig_new_instance_method(_ascpy.Integrator_getObservedVariable)
    getIndependentVariable = _swig_new_instance_method(_ascpy.Integrator_getIndependentVariable)
    findIndependentVar = _swig_new_instance_method(_ascpy.Integrator_findIndependentVar)
    analyse = _swig_new_instance_method(_ascpy.Integrator_analyse)
    solve = _swig_new_instance_method(_ascpy.Integrator_solve)
    writeMatrix = _swig_new_instance_method(_ascpy.Integrator_writeMatrix)
    writeDebug = _swig_new_instance_method(_ascpy.Integrator_writeDebug)
    getCurrentTime = _swig_new_instance_method(_ascpy.Integrator_getCurrentTime)
    getCurrentStep = _swig_new_instance_method(_ascpy.Integrator_getCurrentStep)
    getNumSteps = _swig_new_instance_method(_ascpy.Integrator_getNumSteps)
    getNumVars = _swig_new_instance_method(_ascpy.Integrator_getNumVars)
    getNumObservedVars = _swig_new_instance_method(_ascpy.Integrator_getNumObservedVars)

    def setParameter(self,name,value):
    	""" set the value of a parameter for this integrator """
    	P = self.getParameters()
    	P.set(name,value)
    	self.setParameters(P)
    def getParameterValue(self,name):
    	""" retrieve the *value* of the specified parameter """
    	P = self.getParameters()
    	for p in P:
    		if p.getName()==name:
    			return p.getValue()
    	raise KeyError


# Register Integrator in _ascpy:
_ascpy.Integrator_swigregister(Integrator)
LSODE = cvar.LSODE

class IntegratorReporterCxx(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2):
        if self.__class__ == IntegratorReporterCxx:
            _self = None
        else:
            _self = self
        _ascpy.IntegratorReporterCxx_swiginit(self, _ascpy.new_IntegratorReporterCxx(_self, arg2))
    __swig_destroy__ = _ascpy.delete_IntegratorReporterCxx
    initOutput = _swig_new_instance_method(_ascpy.IntegratorReporterCxx_initOutput)
    closeOutput = _swig_new_instance_method(_ascpy.IntegratorReporterCxx_closeOutput)
    updateStatus = _swig_new_instance_method(_ascpy.IntegratorReporterCxx_updateStatus)
    recordObservedValues = _swig_new_instance_method(_ascpy.IntegratorReporterCxx_recordObservedValues)
    getIntegrator = _swig_new_instance_method(_ascpy.IntegratorReporterCxx_getIntegrator)
    def __disown__(self):
        self.this.disown()
        _ascpy.disown_IntegratorReporterCxx(self)
        return weakref.proxy(self)

# Register IntegratorReporterCxx in _ascpy:
_ascpy.IntegratorReporterCxx_swigregister(IntegratorReporterCxx)
class IntegratorReporterNull(IntegratorReporterCxx):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2):
        _ascpy.IntegratorReporterNull_swiginit(self, _ascpy.new_IntegratorReporterNull(arg2))
    __swig_destroy__ = _ascpy.delete_IntegratorReporterNull

# Register IntegratorReporterNull in _ascpy:
_ascpy.IntegratorReporterNull_swigregister(IntegratorReporterNull)
class IntegratorReporterConsole(IntegratorReporterCxx):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2):
        _ascpy.IntegratorReporterConsole_swiginit(self, _ascpy.new_IntegratorReporterConsole(arg2))
    __swig_destroy__ = _ascpy.delete_IntegratorReporterConsole

# Register IntegratorReporterConsole in _ascpy:
_ascpy.IntegratorReporterConsole_swigregister(IntegratorReporterConsole)
class SolverHooks(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        if self.__class__ == SolverHooks:
            _self = None
        else:
            _self = self
        _ascpy.SolverHooks_swiginit(self, _ascpy.new_SolverHooks(_self, *args))
    __swig_destroy__ = _ascpy.delete_SolverHooks
    setSolver = _swig_new_instance_method(_ascpy.SolverHooks_setSolver)
    setOption = _swig_new_instance_method(_ascpy.SolverHooks_setOption)
    doSolve = _swig_new_instance_method(_ascpy.SolverHooks_doSolve)
    getSolverReporter = _swig_new_instance_method(_ascpy.SolverHooks_getSolverReporter)
    assign = _swig_new_instance_method(_ascpy.SolverHooks_assign)
    def __disown__(self):
        self.this.disown()
        _ascpy.disown_SolverHooks(self)
        return weakref.proxy(self)

# Register SolverHooks in _ascpy:
_ascpy.SolverHooks_swigregister(SolverHooks)
class SolverHooksManager(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Instance = _swig_new_static_method(_ascpy.SolverHooksManager_Instance)
    setHooks = _swig_new_instance_method(_ascpy.SolverHooksManager_setHooks)
    getHooks = _swig_new_instance_method(_ascpy.SolverHooksManager_getHooks)

# Register SolverHooksManager in _ascpy:
_ascpy.SolverHooksManager_swigregister(SolverHooksManager)
class ExtMethod(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ascpy.ExtMethod_swiginit(self, _ascpy.new_ExtMethod(*args))
    getHelp = _swig_new_instance_method(_ascpy.ExtMethod_getHelp)
    getName = _swig_new_instance_method(_ascpy.ExtMethod_getName)
    getNumInputs = _swig_new_instance_method(_ascpy.ExtMethod_getNumInputs)
    getNumOutputs = _swig_new_instance_method(_ascpy.ExtMethod_getNumOutputs)
    __swig_destroy__ = _ascpy.delete_ExtMethod

# Register ExtMethod in _ascpy:
_ascpy.ExtMethod_swigregister(ExtMethod)
class AnnotationDatabase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, dbid):
        _ascpy.AnnotationDatabase_swiginit(self, _ascpy.new_AnnotationDatabase(dbid))
    getNotes = _swig_new_instance_method(_ascpy.AnnotationDatabase_getNotes)
    getTypeRefinedNotesLang = _swig_new_instance_method(_ascpy.AnnotationDatabase_getTypeRefinedNotesLang)
    getNoteForVariable = _swig_new_instance_method(_ascpy.AnnotationDatabase_getNoteForVariable)
    __swig_destroy__ = _ascpy.delete_AnnotationDatabase

# Register AnnotationDatabase in _ascpy:
_ascpy.AnnotationDatabase_swigregister(AnnotationDatabase)
PLOT_TITLE = _ascpy.PLOT_TITLE
PLOT_XLABEL = _ascpy.PLOT_XLABEL
PLOT_YLABEL = _ascpy.PLOT_YLABEL
PLOT_XLOG = _ascpy.PLOT_XLOG
PLOT_YLOG = _ascpy.PLOT_YLOG
PLOT_XLO = _ascpy.PLOT_XLO
PLOT_XHI = _ascpy.PLOT_XHI
PLOT_YLO = _ascpy.PLOT_YLO
PLOT_YHI = _ascpy.PLOT_YHI
PLOT_CURVE = _ascpy.PLOT_CURVE
PLOT_LEGEND = _ascpy.PLOT_LEGEND
PLOT_FORMAT = _ascpy.PLOT_FORMAT
PLOT_LEGENDPOSITION = _ascpy.PLOT_LEGENDPOSITION
PLOT_POINT = _ascpy.PLOT_POINT
PLOT_XPOINT = _ascpy.PLOT_XPOINT
PLOT_YPOINT = _ascpy.PLOT_YPOINT
class Plot(Instance):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, plot):
        _ascpy.Plot_swiginit(self, _ascpy.new_Plot(plot))
    getTitle = _swig_new_instance_method(_ascpy.Plot_getTitle)
    getXLabel = _swig_new_instance_method(_ascpy.Plot_getXLabel)
    getYLabel = _swig_new_instance_method(_ascpy.Plot_getYLabel)
    getLegendPosition = _swig_new_instance_method(_ascpy.Plot_getLegendPosition)
    isXLog = _swig_new_instance_method(_ascpy.Plot_isXLog)
    isYLog = _swig_new_instance_method(_ascpy.Plot_isYLog)
    getXLow = _swig_new_instance_method(_ascpy.Plot_getXLow)
    getXHigh = _swig_new_instance_method(_ascpy.Plot_getXHigh)
    getYLow = _swig_new_instance_method(_ascpy.Plot_getYLow)
    getYHigh = _swig_new_instance_method(_ascpy.Plot_getYHigh)
    curves = property(_ascpy.Plot_curves_get, _ascpy.Plot_curves_set)

    def show(self,mainloop=True):
    	import loading
    	loading.load_matplotlib(throw=True)
    	import pylab
    	import platform
    	pylab.ioff()
    	pylab.figure()
    	pylab.title(self.getTitle())
    #print("XLabel:",self.getXLabel())
    	pylab.xlabel(self.getXLabel())
    #print("YLabel:",self.getYLabel())
    	pylab.ylabel(self.getYLabel())
    	_l = []
    	_have_legends = False
    	for _c in self.curves:
    		_f = _c.getFormat()
    		_args = [_c.x, _c.y]
    		if len(_f):
    			_args += [_f]
    		if self.isXLog() and self.isYLog():
    			pylab.loglog(*_args)
    		elif self.isXLog():
    			pylab.semilogx(*_args)
    		elif self.isYLog():
    			pylab.semilogy(*_args)
    		else:
    			pylab.plot(*_args)
    		_l1 = _c.getLegend()
    		if _l1:
    			_have_legends = True
    		_l.append(_l1)
    # only show legends if their text is non-empty:
    	if _have_legends:
    		pylab.legend(_l,self.getLegendPosition())

    #print("Mainloop:",mainloop)
    	pylab.ion()
    	if platform.system()=="Windows":
    		pylab.show()
    	else:
    		pylab.show(mainloop)


    # /*
    # if self.getXLow() and self.getXHigh():
    #	matplotlib.gca().set_xlim([self.getXLow(), self.getXHigh()])
    # */

    __swig_destroy__ = _ascpy.delete_Plot

# Register Plot in _ascpy:
_ascpy.Plot_swigregister(Plot)
class Curve(Instance):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2):
        _ascpy.Curve_swiginit(self, _ascpy.new_Curve(arg2))
    x = property(_ascpy.Curve_x_get, _ascpy.Curve_x_set)
    y = property(_ascpy.Curve_y_get, _ascpy.Curve_y_set)
    getLegend = _swig_new_instance_method(_ascpy.Curve_getLegend)
    getFormat = _swig_new_instance_method(_ascpy.Curve_getFormat)
    __swig_destroy__ = _ascpy.delete_Curve

# Register Curve in _ascpy:
_ascpy.Curve_swigregister(Curve)

